          ============================================================
          |                                                          |
          |            Crystallography & NMR System (CNS)            |
          |                         CNSsolve                         |
          |                                                          |
          ============================================================
           Version: 1.3
           Status: General release
          ============================================================
           Written by: A.T.Brunger, P.D.Adams, G.M.Clore, W.L.DeLano,
                       P.Gros, R.W.Grosse-Kunstleve,J.-S.Jiang,J.M.Krahn,
                       J.Kuszewski, M.Nilges, N.S.Pannu, R.J.Read,
                       L.M.Rice, G.F.Schroeder, T.Simonson, G.L.Warren.
           Copyright (c) 1997-2010 Yale University
          ============================================================
           Running on machine: login03 (Linux,64-bit)
           Program started by: nminovsk
           Program started at: 07:43:04 on 14-Oct-2020
          ============================================================

 FFT3C: Using FFTPACK4.1

 CNSsolve>eval($filelist="filelist.list") 
 EVALUATE: symbol $FILELIST set to "filelist.list" (string)
 CNSsolve> 
 CNSsolve>evaluate($data.ncomponents=2) 
 EVALUATE: symbol $DATA.NCOMPONENTS set to    2.00000     (real)
 CNSsolve>evaluate($Toppar.prot_segid_1="A") 
 EVALUATE: symbol $TOPPAR.PROT_SEGID_1 set to "A" (string)
 CNSsolve>evaluate($Toppar.prot_segid_2="B") 
 EVALUATE: symbol $TOPPAR.PROT_SEGID_2 set to "B" (string)
 CNSsolve> 
 CNSsolve>eval($epsilon = 1) 
 EVALUATE: symbol $EPSILON set to    1.00000     (real)
 CNSsolve>eval($Data.flags.dihed = FALSE) 
 EVALUATE: symbol $DATA.FLAGS.DIHED set to FALSE (logical)
 CNSsolve>eval($Data.flags.sani = FALSE) 
 EVALUATE: symbol $DATA.FLAGS.SANI set to FALSE (logical)
 CNSsolve>eval($Data.flags.dani = FALSE) 
 EVALUATE: symbol $DATA.FLAGS.DANI set to FALSE (logical)
 CNSsolve>eval($Data.flags.coup = FALSE) 
 EVALUATE: symbol $DATA.FLAGS.COUP set to FALSE (logical)
 CNSsolve>eval($Data.flags.vean = FALSE) 
 EVALUATE: symbol $DATA.FLAGS.VEAN set to FALSE (logical)
 CNSsolve>eval($Data.flags.cdih = FALSE) 
 EVALUATE: symbol $DATA.FLAGS.CDIH set to FALSE (logical)
 CNSsolve>eval($Data.flags.noe = TRUE) 
 EVALUATE: symbol $DATA.FLAGS.NOE set to TRUE (logical)
 CNSsolve>eval($Data.flags.sym= FALSE) 
 EVALUATE: symbol $DATA.FLAGS.SYM set to FALSE (logical)
 CNSsolve>eval($Data.flags.ncs= FALSE) 
 EVALUATE: symbol $DATA.FLAGS.NCS set to FALSE (logical)
 CNSsolve>eval($Data.noecv= FALSE) 
 EVALUATE: symbol $DATA.NOECV set to FALSE (logical)
 CNSsolve>eval($Data.waterdock= TRUE) 
 EVALUATE: symbol $DATA.WATERDOCK set to TRUE (logical)
 CNSsolve> 
 CNSsolve>evaluate ($data.ksym=1.0) 
 EVALUATE: symbol $DATA.KSYM set to    1.00000     (real)
 CNSsolve>evaluate ($data.numc2sym=0) 
 EVALUATE: symbol $DATA.NUMC2SYM set to    0.00000     (real)
 CNSsolve>evaluate ($data.numc3sym=0) 
 EVALUATE: symbol $DATA.NUMC3SYM set to    0.00000     (real)
 CNSsolve>evaluate ($data.numc5sym=0) 
 EVALUATE: symbol $DATA.NUMC5SYM set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.c3sym_sta1_1="") 
 EVALUATE: symbol $TOPPAR.C3SYM_STA1_1 set to "" (string)
 CNSsolve>evaluate ($toppar.c3sym_end1_1="") 
 EVALUATE: symbol $TOPPAR.C3SYM_END1_1 set to "" (string)
 CNSsolve>evaluate ($toppar.c3sym_seg1_1="") 
 EVALUATE: symbol $TOPPAR.C3SYM_SEG1_1 set to "" (string)
 CNSsolve>evaluate ($toppar.c3sym_sta2_1="") 
 EVALUATE: symbol $TOPPAR.C3SYM_STA2_1 set to "" (string)
 CNSsolve>evaluate ($toppar.c3sym_end2_1="") 
 EVALUATE: symbol $TOPPAR.C3SYM_END2_1 set to "" (string)
 CNSsolve>evaluate ($toppar.c3sym_seg2_1="") 
 EVALUATE: symbol $TOPPAR.C3SYM_SEG2_1 set to "" (string)
 CNSsolve>!evaluate ($toppar.c3sym_sta3_1="") 
 CNSsolve>!evaluate ($toppar.c3sym_end3_1="") 
 CNSsolve>!evaluate ($toppar.c3sym_seg3_1="") 
 CNSsolve> 
 CNSsolve>evaluate ($toppar.hisd_resid_1_1=0) 
 EVALUATE: symbol $TOPPAR.HISD_RESID_1_1 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hisd_resid_1_2=0) 
 EVALUATE: symbol $TOPPAR.HISD_RESID_1_2 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hisd_resid_1_3=0) 
 EVALUATE: symbol $TOPPAR.HISD_RESID_1_3 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hisd_resid_1_4=0) 
 EVALUATE: symbol $TOPPAR.HISD_RESID_1_4 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hisd_resid_1_5=0) 
 EVALUATE: symbol $TOPPAR.HISD_RESID_1_5 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hisd_resid_1_6=0) 
 EVALUATE: symbol $TOPPAR.HISD_RESID_1_6 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hisd_resid_1_7=0) 
 EVALUATE: symbol $TOPPAR.HISD_RESID_1_7 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hisd_resid_1_8=0) 
 EVALUATE: symbol $TOPPAR.HISD_RESID_1_8 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hisd_resid_1_9=0) 
 EVALUATE: symbol $TOPPAR.HISD_RESID_1_9 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hisd_resid_1_10=0) 
 EVALUATE: symbol $TOPPAR.HISD_RESID_1_10 set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>evaluate ($toppar.hise_resid_1_1=0) 
 EVALUATE: symbol $TOPPAR.HISE_RESID_1_1 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hise_resid_1_2=0) 
 EVALUATE: symbol $TOPPAR.HISE_RESID_1_2 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hise_resid_1_3=0) 
 EVALUATE: symbol $TOPPAR.HISE_RESID_1_3 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hise_resid_1_4=0) 
 EVALUATE: symbol $TOPPAR.HISE_RESID_1_4 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hise_resid_1_5=0) 
 EVALUATE: symbol $TOPPAR.HISE_RESID_1_5 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hise_resid_1_6=0) 
 EVALUATE: symbol $TOPPAR.HISE_RESID_1_6 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hise_resid_1_7=0) 
 EVALUATE: symbol $TOPPAR.HISE_RESID_1_7 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hise_resid_1_8=0) 
 EVALUATE: symbol $TOPPAR.HISE_RESID_1_8 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hise_resid_1_9=0) 
 EVALUATE: symbol $TOPPAR.HISE_RESID_1_9 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hise_resid_1_10=0) 
 EVALUATE: symbol $TOPPAR.HISE_RESID_1_10 set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>evaluate ($toppar.hisd_resid_2_1=0) 
 EVALUATE: symbol $TOPPAR.HISD_RESID_2_1 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hisd_resid_2_2=0) 
 EVALUATE: symbol $TOPPAR.HISD_RESID_2_2 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hisd_resid_2_3=0) 
 EVALUATE: symbol $TOPPAR.HISD_RESID_2_3 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hisd_resid_2_4=0) 
 EVALUATE: symbol $TOPPAR.HISD_RESID_2_4 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hisd_resid_2_5=0) 
 EVALUATE: symbol $TOPPAR.HISD_RESID_2_5 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hisd_resid_2_6=0) 
 EVALUATE: symbol $TOPPAR.HISD_RESID_2_6 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hisd_resid_2_7=0) 
 EVALUATE: symbol $TOPPAR.HISD_RESID_2_7 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hisd_resid_2_8=0) 
 EVALUATE: symbol $TOPPAR.HISD_RESID_2_8 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hisd_resid_2_9=0) 
 EVALUATE: symbol $TOPPAR.HISD_RESID_2_9 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hisd_resid_2_10=0) 
 EVALUATE: symbol $TOPPAR.HISD_RESID_2_10 set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>evaluate ($toppar.hise_resid_2_1=0) 
 EVALUATE: symbol $TOPPAR.HISE_RESID_2_1 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hise_resid_2_2=0) 
 EVALUATE: symbol $TOPPAR.HISE_RESID_2_2 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hise_resid_2_3=0) 
 EVALUATE: symbol $TOPPAR.HISE_RESID_2_3 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hise_resid_2_4=0) 
 EVALUATE: symbol $TOPPAR.HISE_RESID_2_4 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hise_resid_2_5=0) 
 EVALUATE: symbol $TOPPAR.HISE_RESID_2_5 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hise_resid_2_6=0) 
 EVALUATE: symbol $TOPPAR.HISE_RESID_2_6 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hise_resid_2_7=0) 
 EVALUATE: symbol $TOPPAR.HISE_RESID_2_7 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hise_resid_2_8=0) 
 EVALUATE: symbol $TOPPAR.HISE_RESID_2_8 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hise_resid_2_9=0) 
 EVALUATE: symbol $TOPPAR.HISE_RESID_2_9 set to    0.00000     (real)
 CNSsolve>evaluate ($toppar.hise_resid_2_10=0) 
 EVALUATE: symbol $TOPPAR.HISE_RESID_2_10 set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>!evaluate ($toppar.hisd_resid_3_1=0) 
 CNSsolve>!evaluate ($toppar.hisd_resid_3_2=0) 
 CNSsolve>!evaluate ($toppar.hisd_resid_3_3=0) 
 CNSsolve>!evaluate ($toppar.hisd_resid_3_4=0) 
 CNSsolve>!evaluate ($toppar.hisd_resid_3_5=0) 
 CNSsolve>!evaluate ($toppar.hisd_resid_3_6=0) 
 CNSsolve>!evaluate ($toppar.hisd_resid_3_7=0) 
 CNSsolve>!evaluate ($toppar.hisd_resid_3_8=0) 
 CNSsolve>!evaluate ($toppar.hisd_resid_3_9=0) 
 CNSsolve>!evaluate ($toppar.hisd_resid_3_10=0) 
 CNSsolve>! 
 CNSsolve>!evaluate ($toppar.hise_resid_3_1=0) 
 CNSsolve>!evaluate ($toppar.hise_resid_3_2=0) 
 CNSsolve>!evaluate ($toppar.hise_resid_3_3=0) 
 CNSsolve>!evaluate ($toppar.hise_resid_3_4=0) 
 CNSsolve>!evaluate ($toppar.hise_resid_3_5=0) 
 CNSsolve>!evaluate ($toppar.hise_resid_3_6=0) 
 CNSsolve>!evaluate ($toppar.hise_resid_3_7=0) 
 CNSsolve>!evaluate ($toppar.hise_resid_3_8=0) 
 CNSsolve>!evaluate ($toppar.hise_resid_3_9=0) 
 CNSsolve>!evaluate ($toppar.hise_resid_3_10=0) 
 CNSsolve> 
 CNSsolve>evaluate ($par_nonbonded = "HADDOCK:/toppar/parallhdg5.3.pro" ) 
 EVALUATE: symbol $PAR_NONBONDED set to "HADDOCK:/toppar/parallhdg5.3.pro" (string)
 CNSsolve>parameter @@$par_nonbonded end 
 ASSFIL: file parallhdg5.3.pro opened.
 PARRDR>remark   file parallhdg.param  version 5.3  date 07-JUL-10 
 PARRDR>remark   for file protein-allhdg-ucl.top  version UCL  date 14-MAR-00 
 PARRDR>remark   for file protein-allhdg-dih-ucl.top  version UCL  date 07-JUL-01 
 PARRDR>remark   Geometric energy function parameters for distance geometry and 
 PARRDR>remark   simulated annealing. 
 PARRDR>remark   Original author: Michael Nilges, EMBL Heidelberg 
 PARRDR>remark   Modifications: Mark A. Williams, UCL London 
 PARRDR>remark   Several modifications for HADDOCK: Alexandre Bonvin, Utrecht Uni 
 PARRDR> 
 PARRDR>set echo off message off end 
 PARRDR> end 
 %PARRDR-info: duplication of bond OUF  SUF 
 %PARRDR-info: duplication of angle OUF  SUF  OUF 
 %PARRDR-info: duplication of nonbonded entry SUF 
 %PARRDR-info: duplication of nonbonded entry OUF 
 CNSsolve>parameter @@ligand.param end 
 PARRDR>! 
 PARRDR>! 
 PARRDR>!       This file was generated by PRODRG version 051202.0518 
 PARRDR>!       PRODRG written/copyrighted by Daan van Aalten 
 PARRDR>! 
 PARRDR>!       Questions/comments to dava@davapc1.bioch.dundee.ac.uk 
 PARRDR>! 
 PARRDR>!       When using this software in a publication, cite: 
 PARRDR>!       A. W. Schuettelkopf and D. M. F. van Aalten (2004). 
 PARRDR>!       PRODRG - a tool for high-throughput crystallography 
 PARRDR>!       of protein-ligand complexes. 
 PARRDR>!       Acta Crystallogr. D60, 1355--1363. 
 PARRDR>! 
 PARRDR>! 
 PARRDR>!  *** NOTE *** IF YOU USE MORE THAN ONE PRODRG-GENERATED TOPOLOGY IN CNS, 
 PARRDR>!               PLEASE CAREFULLY READ THE FAQ AS THIS MAY CAUSE PROBLEMS 
 PARRDR>! 
 PARRDR>! 
 PARRDR>set echo=off message=on end 
 EVALUATE: symbol $PD_X set to    1.00000     (real)
 EVALUATE: symbol $PD_V set to    12000.0     (real)
 EVALUATE: symbol $PD_V set to    12000.0     (real)
 EVALUATE: symbol $PD_V set to    18000.0     (real)
 EVALUATE: symbol $PD_V set to    12000.0     (real)
 EVALUATE: symbol $PD_V set to    12000.0     (real)
 EVALUATE: symbol $PD_V set to    18000.0     (real)
 EVALUATE: symbol $PD_V set to    18000.0     (real)
 EVALUATE: symbol $PD_V set to    12000.0     (real)
 EVALUATE: symbol $PD_V set to    12000.0     (real)
 EVALUATE: symbol $PD_V set to    18000.0     (real)
 EVALUATE: symbol $PD_V set to    18000.0     (real)
 EVALUATE: symbol $PD_V set to    12000.0     (real)
 EVALUATE: symbol $PD_V set to    12000.0     (real)
 EVALUATE: symbol $PD_V set to    12000.0     (real)
 EVALUATE: symbol $PD_V set to    12000.0     (real)
 EVALUATE: symbol $PD_V set to    16000.0     (real)
 EVALUATE: symbol $PD_V set to    12000.0     (real)
 EVALUATE: symbol $PD_V set to    16000.0     (real)
 EVALUATE: symbol $PD_V set to    16000.0     (real)
 EVALUATE: symbol $PD_V set to    15000.0     (real)
 EVALUATE: symbol $PD_V set to    16000.0     (real)
 EVALUATE: symbol $PD_V set to    16000.0     (real)
 EVALUATE: symbol $PD_V set to    15000.0     (real)
 EVALUATE: symbol $PD_V set to    12000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    18000.0     (real)
 EVALUATE: symbol $PD_V set to    16000.0     (real)
 EVALUATE: symbol $PD_V set to    17900.0     (real)
 EVALUATE: symbol $PD_V set to    17900.0     (real)
 EVALUATE: symbol $PD_V set to    17900.0     (real)
 EVALUATE: symbol $PD_V set to    16000.0     (real)
 EVALUATE: symbol $PD_V set to    24000.0     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    1120.00     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    1120.00     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    544.000     (real)
 EVALUATE: symbol $PD_V set to    480.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    544.000     (real)
 EVALUATE: symbol $PD_V set to    544.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    560.000     (real)
 EVALUATE: symbol $PD_V set to    560.000     (real)
 EVALUATE: symbol $PD_V set to    640.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    400.000     (real)
 EVALUATE: symbol $PD_V set to    400.000     (real)
 EVALUATE: symbol $PD_V set to    400.000     (real)
 EVALUATE: symbol $PD_V set to    400.000     (real)
 EVALUATE: symbol $PD_V set to    400.000     (real)
 EVALUATE: symbol $PD_V set to    400.000     (real)
 EVALUATE: symbol $PD_V set to    400.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to   0.600000     (real)
 EVALUATE: symbol $PD_V set to    5.60000     (real)
 EVALUATE: symbol $PD_V set to   0.600000     (real)
 EVALUATE: symbol $PD_V set to    5.60000     (real)
 EVALUATE: symbol $PD_V set to   0.600000     (real)
 EVALUATE: symbol $PD_V set to    5.60000     (real)
 EVALUATE: symbol $PD_V set to   0.600000     (real)
 EVALUATE: symbol $PD_V set to    5.60000     (real)
 EVALUATE: symbol $PD_V set to   0.600000     (real)
 EVALUATE: symbol $PD_V set to    5.60000     (real)
 EVALUATE: symbol $PD_V set to    8.10000     (real)
 EVALUATE: symbol $PD_V set to    19.6000     (real)
 EVALUATE: symbol $PD_V set to    8.10000     (real)
 EVALUATE: symbol $PD_V set to    19.6000     (real)
 EVALUATE: symbol $PD_V set to    8.10000     (real)
 EVALUATE: symbol $PD_V set to   0.900000     (real)
 EVALUATE: symbol $PD_V set to    19.6000     (real)
 EVALUATE: symbol $PD_V set to   0.900000     (real)
 EVALUATE: symbol $PD_V set to    19.6000     (real)
 EVALUATE: symbol $PD_V set to    0.00000     (real)
 EVALUATE: symbol $PD_V set to    640.000     (real)
 PARRDR> end 
 %PARRDR-info: duplication of bond OUF  SUF 
 %PARRDR-info: duplication of angle OUF  SUF  OUF 
 %PARRDR-info: duplication of nonbonded entry SUF 
 %PARRDR-info: duplication of nonbonded entry OUF 
 CNSsolve>parameter @@HADDOCK:/toppar/parallhdg5.3.sol end 
 ASSFIL: file parallhdg5.3.sol opened.
 PARRDR>remarks   PARAM19.SOL (solvent parameters) 
 PARRDR>remarks   =========== 
 PARRDR>remarks   available: TIPS3P and DMSO model 
 PARRDR> 
 PARRDR>set echo=false end 
 PARRDR> end 
 %PARRDR-info: duplication of bond OUF  SUF 
 %PARRDR-info: duplication of angle OUF  SUF  OUF 
 %PARRDR-info: duplication of nonbonded entry SUF 
 %PARRDR-info: duplication of nonbonded entry OUF 
 CNSsolve> 
 CNSsolve>evaluate ($link_file = "HADDOCK:/toppar/topallhdg5.3.pep-noter" ) 
 EVALUATE: symbol $LINK_FILE set to "HADDOCK:/toppar/topallhdg5.3.pep-noter" (string)
 CNSsolve>evaluate ($top_file = "HADDOCK:/toppar/topallhdg5.3.pro" ) 
 EVALUATE: symbol $TOP_FILE set to "HADDOCK:/toppar/topallhdg5.3.pro" (string)
 CNSsolve>evaluate ($sol_topology_infile="HADDOCK:/toppar/topallhdg5.3.sol") 
 EVALUATE: symbol $SOL_TOPOLOGY_INFILE set to "HADDOCK:/toppar/topallhdg5.3.sol" (string)
 CNSsolve> 
 CNSsolve> 
 CNSsolve>eval($auto_break=true) 
 EVALUATE: symbol $AUTO_BREAK set to TRUE (logical)
 CNSsolve>eval($break_cutoff=2.5) 
 EVALUATE: symbol $BREAK_CUTOFF set to    2.50000     (real)
 CNSsolve>eval($prot_break_infile="HADDOCK:/toppar/protein_break.top") 
 EVALUATE: symbol $PROT_BREAK_INFILE set to "HADDOCK:/toppar/protein_break.top" (string)
 CNSsolve>topology 
 RTFRDR>  @@$top_file 
 ASSFIL: file topallhdg5.3.pro opened.
 RTFRDR>remark   file topallhdg.pro  version 5.3  date 23-Sept-02 
 RTFRDR>remark      for file parallhdg.pro version 5.3 date 13-Feb-02 or later 
 RTFRDR>remark   Geometric energy function parameters for distance geometry and 
 RTFRDR>remark      simulated annealing. 
 RTFRDR>remark   Author: Michael Nilges, EMBL Heidelberg; Institut Pasteur, Paris 
 RTFRDR>remark   This file contains modifications from M. Williams, UCL London 
 RTFRDR>remark   and multiple modifications for HADDOCK from A. Bonvin, Utrecht University 
 RTFRDR>remark   Last modification 30-April-09 
 RTFRDR> 
 RTFRDR>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 MESSage=NORM
 EVALUATE: symbol $OLD_MESSAGE set to "NORM" (string)
 ECHO=TRUE {ON}
 EVALUATE: symbol $OLD_ECHO set to TRUE (logical)
 RTFRDR>set message=off echo=off end 
 RTFRDR>  @@$sol_topology_infile 
 ASSFIL: file topallhdg5.3.sol opened.
 RTFRDR>remarks  TOPH19.SOL 
 RTFRDR>remarks  ========== 
 RTFRDR>remarks  topology file for solvent molecules 
 RTFRDR>remarks  water models available: TIP3P model 
 RTFRDR> 
 RTFRDR>set echo=false end 
 RTFRDR>  @@$prot_break_infile 
 ASSFIL: file protein_break.top opened.
 RTFRDR>remarks file toppar/protein_break.top 
 RTFRDR>remarks   patches to remove peptide linkages 
 RTFRDR> 
 RTFRDR>! Paul Adams 28th June 1999 
 RTFRDR>! Yale University 
 RTFRDR> 
 RTFRDR>set echo=false end 
 RTFRDR> 
 RTFRDR>  @@ligand.top 
 ASSFIL: file ligand.top opened.
 RTFRDR>! 
 RTFRDR>! 
 RTFRDR>!       This file was generated by PRODRG version 051202.0518 
 RTFRDR>!       PRODRG written/copyrighted by Daan van Aalten 
 RTFRDR>! 
 RTFRDR>!       Questions/comments to dava@davapc1.bioch.dundee.ac.uk 
 RTFRDR>! 
 RTFRDR>!       When using this software in a publication, cite: 
 RTFRDR>!       A. W. Schuettelkopf and D. M. F. van Aalten (2004). 
 RTFRDR>!       PRODRG - a tool for high-throughput crystallography 
 RTFRDR>!       of protein-ligand complexes. 
 RTFRDR>!       Acta Crystallogr. D60, 1355--1363. 
 RTFRDR>! 
 RTFRDR>! 
 RTFRDR>!  *** NOTE *** IF YOU USE MORE THAN ONE PRODRG-GENERATED TOPOLOGY IN CNS, 
 RTFRDR>!               PLEASE CAREFULLY READ THE FAQ AS THIS MAY CAUSE PROBLEMS 
 RTFRDR>! 
 RTFRDR>! 
 RTFRDR>set echo=false end 
 RTFRDR>!  @@HADDOCK:/toppar/ion.top 
 RTFRDR>end 
 CNSsolve>!stop 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>eval($hydrogen_build="all") 
 EVALUATE: symbol $HYDROGEN_BUILD set to "all" (string)
 CNSsolve>eval($set_bfactor=false) 
 EVALUATE: symbol $SET_BFACTOR set to FALSE (logical)
 CNSsolve>evaluate ($log_level=quiet) 
 Assuming literal string "QUIET"
 EVALUATE: symbol $LOG_LEVEL set to "QUIET" (string)
 CNSsolve> 
 CNSsolve>eval($OT1_becomes="O") 
 EVALUATE: symbol $OT1_BECOMES set to "O" (string)
 CNSsolve>eval($OT2_becomes="OXT") 
 EVALUATE: symbol $OT2_BECOMES set to "OXT" (string)
 CNSsolve>eval($ile_CD_becomes="CD1") 
 EVALUATE: symbol $ILE_CD_BECOMES set to "CD1" (string)
 CNSsolve>eval($disulphide_dist=3.0) 
 EVALUATE: symbol $DISULPHIDE_DIST set to    3.00000     (real)
 CNSsolve> 
 CNSsolve>evaluate ($count = 0) 
 EVALUATE: symbol $COUNT set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>for $file in ( @$filelist ) loop readpdb 
 ASSFIL: file filelist.list opened.
 FOR-clause="decoy_1.pdb" 
 FOR LOOP: symbol FILE set to "decoy_1.pdb" (string)
 FOR-clause= ) loop readpdb 
 CNSsolve>!original: for $file in ( @@$filelist ) loop readpdb 
 CNSsolve>  eval($count=$count+1) 
 EVALUATE: symbol $COUNT set to    1.00000     (real)
 CNSsolve>  evaluate ($filename= $file - ".pdb" + "_conv.pdb") 
 EVALUATE: symbol $FILENAME set to "decoy_1_conv.pdb" (string)
 CNSsolve>  evaluate ($psfname= $file - ".pdb" + "_conv.psf") 
 EVALUATE: symbol $PSFNAME set to "decoy_1_conv.psf" (string)
 CNSsolve> 
 CNSsolve>  fileexist $filename end 
 MISCOM: file exists
 CNSsolve>  evaluate ($convfileexist=$result) 
 EVALUATE: symbol $CONVFILEEXIST set to TRUE (logical)
 CNSsolve>  if ($convfileexist eq false) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  dele sele=(all) end 
 CNSsolve>  struc reset end 
 CNSsolve>  noe reset end 
 CNSsolve> 
 CNSsolve>  segment 
 CNSsolve>    chain 
 CNSsolve>      convert=true 
 CNSsolve>      separate=true 
 CNSsolve>      @@$link_file 
 CNSsolve>      coordinates @@$file 
 CNSsolve>    end 
 CNSsolve>  end 
 CNSsolve>  do (name="CD1") (resname ILE and name CD) 
 CNSsolve>  do (name="O") (name OT1) 
 CNSsolve>  do (name="OXT") (name OT2) 
 CNSsolve>  delete sele=(hydrogen and attr charge = 0) end 
 CNSsolve> 
 CNSsolve>  coordinates @@$file 
 CNSsolve> 
 CNSsolve>  show sum(1) ( not(hydrogen) and not(known) ) 
 CNSsolve>  if ( $select = 0 ) then 
 CNSsolve>    display  %INFO: There are no coordinates missing for non-hydrogen atoms 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ( $log_level = verbose ) then 
 CNSsolve>    set message=normal echo=on end 
 CNSsolve>  else 
 CNSsolve>    set message=off echo=off end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ( $auto_break = true ) then 
 CNSsolve>    display test: autobreak 
 CNSsolve>    evaluate ($break=0) 
 CNSsolve> 
 CNSsolve>    for $id1 in id ( name C and bondedto(name CA) and bondedto(name O) ) loop break 
 CNSsolve> 
 CNSsolve>      show (segid) (id $id1) 
 CNSsolve>      evaluate ($segid1=$result) 
 CNSsolve>      show (resid) (id $id1) 
 CNSsolve>      evaluate ($resid1=$result) 
 CNSsolve>      show (resname) (id $id1) 
 CNSsolve>      evaluate ($resname1=$result) 
 CNSsolve> 
 CNSsolve>      show sum(1) (id $id1 and known) 
 CNSsolve>      if ( $result = 0 ) then 
 CNSsolve>        display unknown coordinates for segid $segid1 resname $resname1 resid $resid1 name C 
 CNSsolve>        display this coordinate must be known for automatic chain break detection 
 CNSsolve>        abort 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      identity (store1) ( name N and bondedto( segid $segid1 and resid $resid1 and name c ) ) 
 CNSsolve> 
 CNSsolve>      if ( $select = 1 ) then 
 CNSsolve>        show element (store1) (attribute store1 > 0) 
 CNSsolve>        evaluate ($id2=$result) 
 CNSsolve>        show (segid) (id $id2) 
 CNSsolve>        evaluate ($segid2=$result) 
 CNSsolve>        show (resid) (id $id2) 
 CNSsolve>        evaluate ($resid2=$result) 
 CNSsolve>        show (resname) (id $id2) 
 CNSsolve>        evaluate ($resname2=$result) 
 CNSsolve> 
 CNSsolve>        show sum(1) (id $id2 and known) 
 CNSsolve>        if ( $result = 0 ) then 
 CNSsolve>          display unknown coordinates for segid $segid2 resname $resname2 resid $resid2 name N 
 CNSsolve>          display this coordinate must be known for automatic chain break detection 
 CNSsolve>          abort 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        pick bond 
 CNSsolve>          (name c and segid $segid1 and resid $resid1) 
 CNSsolve>          (name n and segid $segid2 and resid $resid2) 
 CNSsolve>          geometry 
 CNSsolve> 
 CNSsolve>        if ( $result > $break_cutoff ) then 
 CNSsolve>          evaluate ($break=$break+1) 
 CNSsolve>          evaluate ($seg1.$break=$segid1) 
 CNSsolve>          evaluate ($res1.$break=$resid1) 
 CNSsolve>          evaluate ($seg2.$break=$segid2) 
 CNSsolve>          evaluate ($res2.$break=$resid2) 
 CNSsolve>          if ( $resname2 = PRO ) then 
 CNSsolve>            evaluate ($patch.$break=DPPP) 
 CNSsolve>          elseif ( $resname2 = CPR ) then 
 CNSsolve>            evaluate ($patch.$break=DPPP) 
 CNSsolve>          else 
 CNSsolve>            evaluate ($patch.$break=DPEP) 
 CNSsolve>          end if 
 CNSsolve>        end if 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>    end loop break 
 CNSsolve> 
 CNSsolve>    evaluate ($counter=1) 
 CNSsolve> 
 CNSsolve>    while ($counter <= $break) loop delete 
 CNSsolve>      patch $patch.$counter 
 CNSsolve>        reference=-=(segid $seg1.$counter and resid $res1.$counter) 
 CNSsolve>        reference=+=(segid $seg2.$counter and resid $res2.$counter) 
 CNSsolve>      end 
 CNSsolve>      evaluate ($counter=$counter+1) 
 CNSsolve>    end loop delete 
 CNSsolve> 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  eval($nchain = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain = $nchain + 1) 
 CNSsolve> 
 CNSsolve>    !for the histidine patches: 
 CNSsolve>    evaluate($hisd_counter=1) 
 CNSsolve>    while ($hisd_counter le 10) loop hisd 
 CNSsolve>      if ($Toppar.hisd_resid_$nchain_$hisd_counter > 0) then 
 CNSsolve>        show (resn) (tag and resid $Toppar.hisd_resid_$nchain_$hisd_counter) 
 CNSsolve>	if ($result eq "HIS") then 
 CNSsolve>           patch hisd reference=nil=(resid $Toppar.hisd_resid_$nchain_$hisd_counter 
 CNSsolve>	                             and segid $Toppar.prot_segid_$nchain) end 
 CNSsolve>        end if 
 CNSsolve>      end if 
 CNSsolve>      evaluate($hisd_counter=$hisd_counter + 1) 
 CNSsolve>    end loop hisd 
 CNSsolve> 
 CNSsolve>    evaluate($hise_counter=1) 
 CNSsolve>    while ($hise_counter le 10) loop hise 
 CNSsolve>      if ($Toppar.hise_resid_$nchain_$hise_counter > 0) then 
 CNSsolve>        show (resn) (tag and resid $Toppar.hise_resid_$nchain_$hise_counter) 
 CNSsolve>	if ($result eq "HIS") then 
 CNSsolve>          patch hise reference=nil=(resid $Toppar.hise_resid_$nchain_$hise_counter 
 CNSsolve>	                            and segid $Toppar.prot_segid_$nchain) end 
 CNSsolve>        end if 
 CNSsolve>      end if 
 CNSsolve>      evaluate($hise_counter=$hise_counter + 1) 
 CNSsolve>    end loop hise 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  evaluate ($disu=0) 
 CNSsolve> 
 CNSsolve>  for $id1 in id ( resname CYS and name SG ) loop dis1 
 CNSsolve>    display test: dis1 $id1 
 CNSsolve> 
 CNSsolve>    show (segid) (id $id1) 
 CNSsolve>    evaluate ($segid1=$result) 
 CNSsolve>    show (resid) (id $id1) 
 CNSsolve>    evaluate ($resid1=$result) 
 CNSsolve> 
 CNSsolve>    identity (store1) (all) 
 CNSsolve> 
 CNSsolve>    for $id2 in id ( resname CYS and name SG and 
 FOR-clause=                  ( attr store1 > $id1 ) ) loop dis2 
 CNSsolve> 
 CNSsolve>      show (segid) (id $id2) 
 CNSsolve>      evaluate ($segid2=$result) 
 CNSsolve>      show (resid) (id $id2) 
 CNSsolve>      evaluate ($resid2=$result) 
 CNSsolve> 
 CNSsolve>      pick bond (id $id1) (id $id2) geometry 
 CNSsolve> 
 CNSsolve>      if ( $result <= $disulphide_dist ) then 
 CNSsolve>        evaluate ($disu=$disu+1) 
 CNSsolve>        evaluate ($seg1.$disu=$segid1) 
 CNSsolve>        evaluate ($seg2.$disu=$segid2) 
 CNSsolve>        evaluate ($res1.$disu=$resid1) 
 CNSsolve>        evaluate ($res2.$disu=$resid2) 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>    end loop dis2 
 CNSsolve> 
 CNSsolve>  end loop dis1 
 CNSsolve> 
 CNSsolve>  evaluate ($counter=1) 
 CNSsolve>  while ( $counter <= $disu ) loop disu 
 CNSsolve>    display test: disu $counter 
 CNSsolve>    patch disu 
 CNSsolve>      reference=1=(segid $seg1.$counter and resid $res1.$counter) 
 CNSsolve>      reference=2=(segid $seg2.$counter and resid $res2.$counter) 
 CNSsolve>    end 
 CNSsolve>    evaluate ($counter=$counter+1) 
 CNSsolve>  end loop disu 
 CNSsolve> 
 CNSsolve>  for $id in id ( known and not hydrogen and name ca and resname PRO) loop cisp 
 CNSsolve> 
 CNSsolve>    show (segid) (id $id) 
 CNSsolve>    evaluate ($segid=$result) 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($resid=$result) 
 CNSsolve>    show (resname) (id $id) 
 CNSsolve>    evaluate ($resname=$result) 
 CNSsolve> 
 CNSsolve>    identity (store1) ( known and not hydrogen and ( name c and bondedto 
 CNSsolve>             ( name n and resid $resid and segid $segid ) ) ) 
 CNSsolve>    if ( $select = 1 ) then 
 CNSsolve>      show element (store1) (attribute store1 > 0) 
 CNSsolve>      evaluate ($id_prev=$result) 
 CNSsolve>      show (segid) (id $id_prev) 
 CNSsolve>      evaluate ($segid_prev=$result) 
 CNSsolve>      show (resid) (id $id_prev) 
 CNSsolve>      evaluate ($resid_prev=$result) 
 CNSsolve>      show (resname) (id $id_prev) 
 CNSsolve>      evaluate ($resname_prev=$result) 
 CNSsolve> 
 CNSsolve>      pick dihedral 
 CNSsolve>        (name ca and segid $segid_prev and resid $resid_prev) 
 CNSsolve>        (name  c and segid $segid_prev and resid $resid_prev) 
 CNSsolve>        (name  n and segid $segid and resid $resid) 
 CNSsolve>        (name ca and segid $segid and resid $resid) 
 CNSsolve>        geometry 
 CNSsolve> 
 CNSsolve>      evaluate ($dihedral=mod($result+360,360)) 
 CNSsolve> 
 CNSsolve>      if ( $dihedral > 180 ) then 
 CNSsolve>        evaluate ($dihedral=$dihedral-360) 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      evaluate ($absdihedral=abs($dihedral)) 
 CNSsolve> 
 CNSsolve>      if ( $absdihedral < 25 ) then 
 CNSsolve>        patch cisp reference=NIL=(segid $segid_prev and resid $resid_prev) end 
 CNSsolve>        display CIS peptide bon detected for residue $resid_prev 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>  end loop cisp 
 CNSsolve> 
 CNSsolve>  identity (store1) (none) 
 CNSsolve> 
 CNSsolve>  identity (store1) (not(known)) 
 CNSsolve> 
 CNSsolve>  show sum(1) (store1) 
 CNSsolve>  evaluate ($tobuild=$result) 
 CNSsolve> 
 CNSsolve>  if ( $tobuild > 0 ) then 
 CNSsolve> 
 CNSsolve>    fix selection=(not(store1)) end 
 CNSsolve> 
 CNSsolve>    show sum(1) (store1) 
 CNSsolve>    evaluate ($moving=$result) 
 CNSsolve> 
 CNSsolve>    if ( $moving > 0 ) then 
 CNSsolve>      for $id in id (tag and byres(store1)) loop avco 
 CNSsolve> 
 CNSsolve>        show ave(x) (byres(id $id) and known) 
 CNSsolve>        evaluate ($ave_x=$result) 
 CNSsolve>        show ave(y) (byres(id $id) and known) 
 CNSsolve>        evaluate ($ave_y=$result) 
 CNSsolve>        show ave(z) (byres(id $id) and known) 
 CNSsolve>        evaluate ($ave_z=$result) 
 CNSsolve> 
 CNSsolve>        do (x=$ave_x) (byres(id $id) and store1) 
 CNSsolve>        do (y=$ave_y) (byres(id $id) and store1) 
 CNSsolve>        do (z=$ave_z) (byres(id $id) and store1) 
 CNSsolve> 
 CNSsolve>      end loop avco 
 CNSsolve> 
 CNSsolve>      do (x=x+random(2.0)) (store1) 
 CNSsolve>      do (y=y+random(2.0)) (store1) 
 CNSsolve>      do (z=z+random(2.0)) (store1) 
 CNSsolve> 
 CNSsolve>      {- start parameter for the side chain building -} 
 CNSsolve>      parameter 
 CNSsolve>        nbonds 
 CNSsolve>          rcon=20. nbxmod=-2 repel=0.9  wmin=0.1 tolerance=1. 
 CNSsolve>          rexp=2 irexp=2 inhibit=0.5 
 CNSsolve>        end 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {- Friction coefficient, in 1/ps. -} 
 CNSsolve>      do (fbeta=100) (store1) 
 CNSsolve> 
 CNSsolve>      evaluate ($bath=300.0) 
 CNSsolve>      evaluate ($nstep=500) 
 CNSsolve>      evaluate ($timestep=0.0005) 
 CNSsolve> 
 CNSsolve>      do (refy=mass) (store1) 
 CNSsolve> 
 CNSsolve>      do (mass=20) (store1) 
 CNSsolve> 
 CNSsolve>      igroup interaction 
 CNSsolve>        (store1) (store1 or known) 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {- turn on initial energy terms -} 
 CNSsolve>      flags exclude * include bond angle vdw end 
 CNSsolve> 
 CNSsolve>      minimize powell nstep=50  nprint=10 end 
 CNSsolve> 
 CNSsolve>      do (vx=maxwell($bath)) (store1) 
 CNSsolve>      do (vy=maxwell($bath)) (store1) 
 CNSsolve>      do (vz=maxwell($bath)) (store1) 
 CNSsolve> 
 CNSsolve>      flags exclude vdw include impr end 
 CNSsolve> 
 CNSsolve>      dynamics cartesian 
 CNSsolve>        nstep=50 
 CNSsolve>        timestep=$timestep 
 CNSsolve>        tcoupling=true temperature=$bath 
 CNSsolve>        nprint=$nstep 
 CNSsolve>        cmremove=false 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      flags include vdw end 
 CNSsolve> 
 CNSsolve>      minimize powell nstep=50 nprint=10 end 
 CNSsolve> 
 CNSsolve>      do (vx=maxwell($bath)) (store1) 
 CNSsolve>      do (vy=maxwell($bath)) (store1) 
 CNSsolve>      do (vz=maxwell($bath)) (store1) 
 CNSsolve> 
 CNSsolve>      dynamics cartesian 
 CNSsolve>        nstep=50 
 CNSsolve>        timestep=$timestep 
 CNSsolve>        tcoupling=true temperature=$bath 
 CNSsolve>        nprint=$nstep 
 CNSsolve>        cmremove=false 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      parameter 
 CNSsolve>        nbonds 
 CNSsolve>          rcon=2. nbxmod=-3 repel=0.75 
 CNSsolve>        end 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      minimize powell nstep=100 nprint=25 end 
 CNSsolve> 
 CNSsolve>      do (vx=maxwell($bath)) (store1) 
 CNSsolve>      do (vy=maxwell($bath)) (store1) 
 CNSsolve>      do (vz=maxwell($bath)) (store1) 
 CNSsolve> 
 CNSsolve>      dynamics cartesian 
 CNSsolve>        nstep=$nstep 
 CNSsolve>        timestep=$timestep 
 CNSsolve>        tcoupling=true temperature=$bath 
 CNSsolve>        nprint=$nstep 
 CNSsolve>        cmremove=false 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {- turn on all energy terms -} 
 CNSsolve>      flags include dihe ? end 
 CNSsolve> 
 CNSsolve>      {- set repel to ~vdw radii -} 
 CNSsolve>      parameter 
 CNSsolve>        nbonds 
 CNSsolve>          repel=0.89 
 CNSsolve>        end 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      minimize powell nstep=500 nprint=50 end 
 CNSsolve> 
 CNSsolve>      flag include elec end 
 CNSsolve>      energy end 
 CNSsolve>      flags exclude * include bond angl impr dihe vdw end 
 CNSsolve> 
 CNSsolve>      {- return masses to something sensible -} 
 CNSsolve>      do (mass=refy) (store1) 
 CNSsolve> 
 CNSsolve>      do (vx=maxwell($bath)) (store1) 
 CNSsolve>      do (vy=maxwell($bath)) (store1) 
 CNSsolve>      do (vz=maxwell($bath)) (store1) 
 CNSsolve> 
 CNSsolve>      dynamics cartesian 
 CNSsolve>        nstep=$nstep 
 CNSsolve>        timestep=$timestep 
 CNSsolve>        tcoupling=true temperature=$bath 
 CNSsolve>        nprint=$nstep 
 CNSsolve>        cmremove=false 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {- some final minimisation -} 
 CNSsolve>      minimize powell 
 CNSsolve>        nstep=500 
 CNSsolve>        drop=40.0 
 CNSsolve>        nprint=50 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      print thres=0.02 bonds 
 CNSsolve>      print thres=5. angles 
 CNSsolve> 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    fix selection=( none ) end 
 CNSsolve> 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if (&set_bfactor=true) then 
 CNSsolve>    do (b=&bfactor) ( all ) 
 CNSsolve>  else 
 CNSsolve>    show ave(b) (known and not(store1)) 
 CNSsolve>    do (b=$result) (store1 and (attr b < 0.01)) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  set remarks=reset end 
 CNSsolve> 
 CNSsolve>{* ===================== turn on electrostatics *} 
 CNSsolve> 
 CNSsolve>  parameter 
 CNSsolve>    nbonds 
 CNSsolve>      nbxmod=5 atom cdie shift 
 CNSsolve>      cutnb=9.5 ctofnb=8.5 ctonnb=6.5 eps=$epsilon e14fac=0.4 inhibit 0.5 
 CNSsolve>      wmin=0.5 
 CNSsolve>      tolerance  0.5 
 CNSsolve>      repel=0.0 
 CNSsolve>    end 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  flags excl * incl bond angl impr dihe vdw elec end 
 CNSsolve> 
 CNSsolve>{* ===================== calculate free molecules internal energy *} 
 CNSsolve> 
 CNSsolve>  do (refx=x) (all) 
 CNSsolve>  do (refy=y) (all) 
 CNSsolve>  do (refz=z) (all) 
 CNSsolve>  inline @calc_free-ene.cns 
 ASSFIL: file calc_free-ene.cns opened.
 CNSsolve>!$Revision:$ 
 CNSsolve>!$Date:$ 
 CNSsolve>!$RCSfile:$ 
 CNSsolve>! 
 CNSsolve>!     *********************************** 
 CNSsolve>!     * Authors and copyright:           * 
 CNSsolve>!     * Alexandre Bonvin, Utrecht        * 
 CNSsolve>!     * No warranty implied or expressed * 
 CNSsolve>!     * All rights reserved              * 
 CNSsolve>!     ************************************ 
 CNSsolve> 
 CNSsolve>!move molecules far apart 
 CNSsolve>@separate.cns(Data=$Data; Toppar=$Toppar) 
 ASSFIL: file separate.cns opened.
 CNSsolve>! module to separate the molecules in space 
 CNSsolve>! put molecules 50A away from each other 
 CNSsolve>! 
 CNSsolve>Module(Data;Toppar;) 
 CNSsolve> 
 CNSsolve>  evaluate ($spacing=50) 
 CNSsolve>  evaluate ($trdis=$spacing/2) 
 CNSsolve>  evaluate ($trc=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve>  evaluate ($trd=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = 0) 
 CNSsolve> 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nsloop1 
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 CNSsolve>    eval($watersegname_$ncount="WAT" + encode($ncount)) 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 CNSsolve>    do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>  end loop nsloop1 
 CNSsolve> 
 CNSsolve>  do (x = xcomp) (not (resn DAN or resn ANI)) 
 CNSsolve>  do (y = ycomp) (not (resn DAN or resn ANI)) 
 CNSsolve>  do (z = zcomp) (not (resn DAN or resn ANI)) 
 CNSsolve> 
 CNSsolve>  show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>  evaluate ($xt = -$trdis - $result ) 
 CNSsolve>  coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>  show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>  evaluate ($xt = $trdis - $result ) 
 CNSsolve>  coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>  if ($data.ncomponents>2) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = $trc - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>3) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($zt = $trd - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>4) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -($trd - $result) ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>5) then 
 CNSsolve>    evaluate ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.ncomponents) loop nsloop2 
 CNSsolve>      evaluate ($ncount = $ncount +1) 
 CNSsolve>      show ave (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($xdis=-$result) 
 CNSsolve>      show ave (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($ydis=-$result) 
 CNSsolve>      show ave (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($zdis=-$result) 
 CNSsolve>      coor trans sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) vector=($xdis,$ydis,$zdis) end 
 CNSsolve>    end loop nsloop2 
 CNSsolve> 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,0) end 
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,0,$zt) end 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_6 or segid $watersegname_6) 
 CNSsolve>    evaluate ($zt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_6 or segid $watersegname_6) vector=(0,0,$zt) end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve>  interaction (not (resname ANI or resname DAN)) (not (resname ANI or resname DAN)) 
 CNSsolve>  interaction (    resname ANI) (    resname ANI) 
 CNSsolve>  interaction (    resname DAN) (    resname DAN) 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>evaluate ($eintfree = 0.0) 
 CNSsolve>minimize powell nstep=50 drop=10.0 nprint=25 end 
 CNSsolve>param nbonds eps=1.0 end end 
 CNSsolve>energy end 
 CNSsolve>evaluate ($eintfree = $bond + $angl + $impr + $dihe + $vdw + $elec) 
 CNSsolve> 
 CNSsolve>display FREE MOLECULES INTERNAL ENERGY = $eintfree 
 CNSsolve> 
 CNSsolve>{====>} {* define ASA-based solvation parameters *} 
 CNSsolve>inline @def_solv_param.cns 
 ASSFIL: file def_solv_param.cns opened.
 CNSsolve>! 
 CNSsolve>! Define atomic solvation parameters taken from Fernandez-Recia et al. JMB 335:843 (2004) 
 CNSsolve>! 
 CNSsolve>evaluate ($arofac = 6.26) 
 CNSsolve>evaluate ($alifac = 1.27) 
 CNSsolve>evaluate ($polfac = 2.30) 
 CNSsolve>do (store1 =  0.0000) (all) 
 CNSsolve>do (store1 =  0.0151 * $alifac) (name C*) 
 CNSsolve>do (store1 =  0.0176 * $arofac) ((name CG* or name CD* or name CE* or name CH* or name CZ*) and (resn PHE or resn TYR or resn HIS or resn TRP)) 
 CNSsolve>do (store1 = -0.0170 * $polfac) (name N*) 
 CNSsolve>do (store1 = -0.0548 * $polfac) (name NT* or (name NZ* and resn LYS)) 
 CNSsolve>do (store1 = -0.0273 * $polfac) (name NH* and resn ARG) 
 CNSsolve>do (store1 = -0.0136 * $polfac) (name O*) 
 CNSsolve>do (store1 = -0.0185 * $polfac) (name OG* or name OH) 
 CNSsolve>do (store1 = -0.0299 * $polfac) ((name OD* and resn ASP) or (name OE* and resn GLU)) 
 CNSsolve>do (store1 =  0.0112 * $polfac) (name S*) 
 CNSsolve>do (store1 =  0.0022 * $polfac) ((name S* and attr charge = -0.3) or (name SD and resn MET)) 
 CNSsolve> 
 CNSsolve>{====>} {* buried surface area *} 
 CNSsolve>evaluate ($esolfree = 0) 
 CNSsolve>evaluate ($nchain1 = 1) 
 CNSsolve>evaluate ($saafree = 0) 
 CNSsolve>while ($nchain1 <= $data.ncomponents) loop nloop1 
 CNSsolve>  coor orient sele=(segid $Toppar.prot_segid_$nchain1 and not (resn TIP3 or resn DMS)) end 
 CNSsolve>  {====>} {* buried surface area *} 
 CNSsolve>  do (rmsd = 0) (all) 
 CNSsolve>  do (store2 = 0) (all) 
 CNSsolve>  surface mode=access accu=0.075 rh2o=1.4 sele=(segid $Toppar.prot_segid_$nchain1 and not (resn TIP3 or resn DMS)) end 
 CNSsolve>  show sum (rmsd) (segid $Toppar.prot_segid_$nchain1 and not (resn TIP3 or resn DMS)) 
 CNSsolve>  evaluate ($saafree = $saafree + $result) 
 CNSsolve>  do (store2 = rmsd * store1) (segid $Toppar.prot_segid_$nchain1 and not (resn TIP3 or resn DMS)) 
 CNSsolve>  show sum (store2) (segid $Toppar.prot_segid_$nchain1 and not (resn TIP3 or resn DMS)) 
 CNSsolve>  evaluate ($esolfree = $esolfree + $result) 
 CNSsolve>  evaluate ($nchain1 = $nchain1 + 1) 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>  do (x=refx) (all) 
 CNSsolve>  do (y=refy) (all) 
 CNSsolve>  do (z=refz) (all) 
 CNSsolve> 
 CNSsolve>{* ===================== minimize complex *} 
 CNSsolve> 
 CNSsolve>  parameter nbonds eps=$epsilon end end 
 CNSsolve> 
 CNSsolve>!  fix selection=(not(store1)) end 
 CNSsolve>  fix selection=(segid B or (name P or name N1 or name CA or name C or name N or name O)) end 
 CNSsolve>  minimize powell 
 CNSsolve>    nstep=50 
 CNSsolve>    drop=40.0 
 CNSsolve>    nprint=50 
 CNSsolve>  end 
 CNSsolve>  fix selection=(not all) end 
 CNSsolve> 
 CNSsolve>  parameter nbonds eps=1.0 end end 
 CNSsolve> 
 CNSsolve>{* ===================== calculate symmetry energy *} 
 CNSsolve> 
 CNSsolve>  noe reset nres=10000 end 
 CNSsolve>  @symmultimer.cns 
 ASSFIL: file symmultimer.cns opened.
 CNSsolve>!$Revision: 1.0 $ 
 CNSsolve>!$Date: 2003/02/19 08:14:08 $ 
 CNSsolve>!$RCSfile: symdimer.cns,v $ 
 CNSsolve> 
 CNSsolve>! Define NCS restraints for symmetrical multimers 
 CNSsolve>if ($Data.flags.ncs eq true) then 
 CNSsolve> 
 CNSsolve>  ncs restraints 
 CNSsolve>    initialize 
 CNSsolve>    eval ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.numncs) loop ncsloop 
 CNSsolve>      eval ($ncount = $ncount + 1) 
 CNSsolve>      group 
 CNSsolve>        equi (resid $Toppar.ncs_sta1_$ncount : $Toppar.ncs_end1_$ncount and segid $Toppar.ncs_seg1_$ncount) 
 CNSsolve>        equi (resid $Toppar.ncs_sta2_$ncount : $Toppar.ncs_end2_$ncount and segid $Toppar.ncs_seg2_$ncount) 
 CNSsolve>	weight = $Data.kncs 
 CNSsolve>      end 
 CNSsolve>    end loop ncsloop 
 CNSsolve>    ? 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>! Define C2 symmetry restraints for symmetrical multimers 
 CNSsolve>! 
 CNSsolve>if ($Data.flags.sym eq true) then 
 CNSsolve> 
 CNSsolve>  noe class symm end 
 CNSsolve> 
 CNSsolve>  eval ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.numc2sym) loop c2symloop 
 CNSsolve> 
 CNSsolve>    eval ($ncount = $ncount + 1) 
 CNSsolve>    evaluate ($i1start = decode($Toppar.c2sym_sta1_$ncount)) 
 CNSsolve>    evaluate ($i1end   = decode($Toppar.c2sym_end1_$ncount)) 
 CNSsolve>    evaluate ($chain1  = $Toppar.c2sym_seg1_$ncount) 
 CNSsolve>    evaluate ($i2start = decode($Toppar.c2sym_sta2_$ncount)) 
 CNSsolve>    evaluate ($i2end   = decode($Toppar.c2sym_end2_$ncount)) 
 CNSsolve>    evaluate ($chain2  = $Toppar.c2sym_seg2_$ncount) 
 CNSsolve> 
 CNSsolve>    !first check that the chain lengths are equal for the two defined molecules 
 CNSsolve>    evaluate ($diff1 = $i1end - $i1start) 
 CNSsolve>    evaluate ($diff2 = $i2end - $i2start) 
 CNSsolve>    if ($diff1 ne $diff2) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    eval ($icount = 0) 
 CNSsolve>    while ($i1start < $i1end) loop genc2sym 
 CNSsolve> 
 CNSsolve>      evaluate ($resid1 = $i1start) 
 CNSsolve>      evaluate ($resid2 = $i2end - $icount) 
 CNSsolve>      evaluate ($resid3 = $i2start) 
 CNSsolve>      evaluate ($resid4 = $i1end - $icount) 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve>	assign (resid $resid1 and name CA  and segid $chain1) 
 CNSsolve>	       (resid $resid2 and name CA  and segid $chain2) 0 0 0 
 CNSsolve>	assign (resid $resid3 and name CA  and segid $chain2) 
 CNSsolve>	       (resid $resid4 and name CA  and segid $chain1) 0 0 0 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($icount = $icount + 1) 
 CNSsolve>      evaluate ($i1start = $i1start + 1) 
 CNSsolve>      evaluate ($i2start = $i2start + 1) 
 CNSsolve> 
 CNSsolve>    end loop genc2sym 
 CNSsolve> 
 CNSsolve>  end loop c2symloop 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>! Define C3 symmetry restraints for symmetrical multimers 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>  eval ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.numc3sym) loop c3symloop 
 CNSsolve> 
 CNSsolve>    eval ($ncount = $ncount + 1) 
 CNSsolve>    evaluate ($i1start = decode($Toppar.c3sym_sta1_$ncount)) 
 CNSsolve>    evaluate ($i1end   = decode($Toppar.c3sym_end1_$ncount)) 
 CNSsolve>    evaluate ($chain1  = $Toppar.c3sym_seg1_$ncount) 
 CNSsolve>    evaluate ($i2start = decode($Toppar.c3sym_sta2_$ncount)) 
 CNSsolve>    evaluate ($i2end   = decode($Toppar.c3sym_end2_$ncount)) 
 CNSsolve>    evaluate ($chain2  = $Toppar.c3sym_seg2_$ncount) 
 CNSsolve>    evaluate ($i3start = decode($Toppar.c3sym_sta3_$ncount)) 
 CNSsolve>    evaluate ($i3end   = decode($Toppar.c3sym_end3_$ncount)) 
 CNSsolve>    evaluate ($chain3  = $Toppar.c3sym_seg3_$ncount) 
 CNSsolve> 
 CNSsolve>    !first check that the chain lengths are equal for the two defined molecules 
 CNSsolve>    evaluate ($diff1 = $i1end - $i1start) 
 CNSsolve>    evaluate ($diff2 = $i2end - $i2start) 
 CNSsolve>    evaluate ($diff3 = $i3end - $i3start) 
 CNSsolve>    if ($diff1 ne $diff2) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff1 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff2 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    eval ($icount = 0) 
 CNSsolve>    while ($i1start < $i1end) loop genc3sym 
 CNSsolve> 
 CNSsolve>      evaluate ($resst1 = $i1start) 
 CNSsolve>      evaluate ($resst2 = $i2start) 
 CNSsolve>      evaluate ($resst3 = $i3start) 
 CNSsolve>      evaluate ($resen1 = $i1end - $icount) 
 CNSsolve>      evaluate ($resen2 = $i2end - $icount) 
 CNSsolve>      evaluate ($resen3 = $i3end - $icount) 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve> 
 CNSsolve>         assign (resid $resst1 and name CA  and segid $chain1) 
 CNSsolve>                (resid $resen2 and name CA  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst2 and name CA  and segid $chain2) 
 CNSsolve>                (resid $resen3 and name CA  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and name CA  and segid $chain2) 
 CNSsolve>                (resid $resen3 and name CA  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst3 and name CA  and segid $chain3) 
 CNSsolve>                (resid $resen1 and name CA  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and name CA  and segid $chain3) 
 CNSsolve>                (resid $resen1 and name CA  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resst1 and name CA  and segid $chain1) 
 CNSsolve>                (resid $resen2 and name CA  and segid $chain2) 0 0 0 
 CNSsolve> 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($icount = $icount + 2) 
 CNSsolve>      evaluate ($i1start = $i1start + 2) 
 CNSsolve>      evaluate ($i2start = $i2start + 2) 
 CNSsolve>      evaluate ($i3start = $i3start + 2) 
 CNSsolve> 
 CNSsolve>    end loop genc3sym 
 CNSsolve> 
 CNSsolve>  end loop c3symloop 
 CNSsolve> 
 CNSsolve>! Define C5 symmetry restraints for symmetrical multimers 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>  eval ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.numc5sym) loop c5symloop 
 CNSsolve> 
 CNSsolve>    eval ($ncount = $ncount + 1) 
 CNSsolve>    evaluate ($i1start = decode($Toppar.c5sym_sta1_$ncount)) 
 CNSsolve>    evaluate ($i1end   = decode($Toppar.c5sym_end1_$ncount)) 
 CNSsolve>    evaluate ($chain1  = $Toppar.c5sym_seg1_$ncount) 
 CNSsolve>    evaluate ($i2start = decode($Toppar.c5sym_sta2_$ncount)) 
 CNSsolve>    evaluate ($i2end   = decode($Toppar.c5sym_end2_$ncount)) 
 CNSsolve>    evaluate ($chain2  = $Toppar.c5sym_seg2_$ncount) 
 CNSsolve>    evaluate ($i3start = decode($Toppar.c5sym_sta3_$ncount)) 
 CNSsolve>    evaluate ($i3end   = decode($Toppar.c5sym_end3_$ncount)) 
 CNSsolve>    evaluate ($chain3  = $Toppar.c5sym_seg3_$ncount) 
 CNSsolve>    evaluate ($i4start = decode($Toppar.c5sym_sta4_$ncount)) 
 CNSsolve>    evaluate ($i4end   = decode($Toppar.c5sym_end4_$ncount)) 
 CNSsolve>    evaluate ($chain4  = $Toppar.c5sym_seg4_$ncount) 
 CNSsolve>    evaluate ($i5start = decode($Toppar.c5sym_sta5_$ncount)) 
 CNSsolve>    evaluate ($i5end   = decode($Toppar.c5sym_end5_$ncount)) 
 CNSsolve>    evaluate ($chain5  = $Toppar.c5sym_seg5_$ncount) 
 CNSsolve> 
 CNSsolve>    !first check that the chain lengths are equal for the two defined molecules 
 CNSsolve>    evaluate ($diff1 = $i1end - $i1start) 
 CNSsolve>    evaluate ($diff2 = $i2end - $i2start) 
 CNSsolve>    evaluate ($diff3 = $i3end - $i3start) 
 CNSsolve>    evaluate ($diff4 = $i4end - $i4start) 
 CNSsolve>    evaluate ($diff5 = $i5end - $i5start) 
 CNSsolve>    if ($diff1 ne $diff2) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff1 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff2 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff3 ne $diff4) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff4 ne $diff5) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    eval ($icount = 0) 
 CNSsolve>    while ($i1start < $i1end) loop genc5sym 
 CNSsolve> 
 CNSsolve>      evaluate ($resst1 = $i1start) 
 CNSsolve>      evaluate ($resst2 = $i2start) 
 CNSsolve>      evaluate ($resst3 = $i3start) 
 CNSsolve>      evaluate ($resst4 = $i4start) 
 CNSsolve>      evaluate ($resst5 = $i5start) 
 CNSsolve>      evaluate ($resen1 = $i1end - $icount) 
 CNSsolve>      evaluate ($resen2 = $i2end - $icount) 
 CNSsolve>      evaluate ($resen3 = $i3end - $icount) 
 CNSsolve>      evaluate ($resen4 = $i4end - $icount) 
 CNSsolve>      evaluate ($resen5 = $i5end - $icount) 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve>{ 
 CNSsolve>         assign (resid $resst1 and name CA  and segid $chain1) 
 CNSsolve>                (resid $resen2 and name CA  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst2 and name CA  and segid $chain2) 
 CNSsolve>                (resid $resen3 and name CA  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and name CA  and segid $chain2) 
 CNSsolve>                (resid $resen3 and name CA  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst3 and name CA  and segid $chain3) 
 CNSsolve>                (resid $resen4 and name CA  and segid $chain4) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and name CA  and segid $chain3) 
 CNSsolve>                (resid $resen4 and name CA  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resst4 and name CA  and segid $chain4) 
 CNSsolve>                (resid $resen5 and name CA  and segid $chain5) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst4 and name CA  and segid $chain4) 
 CNSsolve>                (resid $resen5 and name CA  and segid $chain5) 0 0 0 
 CNSsolve>         assign (resid $resst5 and name CA  and segid $chain5) 
 CNSsolve>                (resid $resen1 and name CA  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst5 and name CA  and segid $chain5) 
 CNSsolve>                (resid $resen1 and name CA  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resst1 and name CA  and segid $chain1) 
 CNSsolve>                (resid $resen2 and name CA  and segid $chain2) 0 0 0 
 CNSsolve>} 
 CNSsolve>         assign (resid $resst1 and name CA  and segid $chain1) 
 CNSsolve>                (resid $resst3 and name CA  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst1 and name CA  and segid $chain1) 
 CNSsolve>                (resid $resst4 and name CA  and segid $chain4) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and name CA  and segid $chain2) 
 CNSsolve>                (resid $resst4 and name CA  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resst2 and name CA  and segid $chain2) 
 CNSsolve>                (resid $resst5 and name CA  and segid $chain5) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and name CA  and segid $chain3) 
 CNSsolve>                (resid $resst5 and name CA  and segid $chain5) 0 0 0 
 CNSsolve>         assign (resid $resst3 and name CA  and segid $chain3) 
 CNSsolve>                (resid $resst1 and name CA  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst4 and name CA  and segid $chain4) 
 CNSsolve>                (resid $resst1 and name CA  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resst4 and name CA  and segid $chain4) 
 CNSsolve>                (resid $resst2 and name CA  and segid $chain2) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst5 and name CA  and segid $chain5) 
 CNSsolve>                (resid $resst2 and name CA  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst5 and name CA  and segid $chain5) 
 CNSsolve>                (resid $resst3 and name CA  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($icount = $icount + 2) 
 CNSsolve>      evaluate ($i1start = $i1start + 2) 
 CNSsolve>      evaluate ($i2start = $i2start + 2) 
 CNSsolve>      evaluate ($i3start = $i3start + 2) 
 CNSsolve>      evaluate ($i4start = $i4start + 2) 
 CNSsolve>      evaluate ($i5start = $i5start + 2) 
 CNSsolve> 
 CNSsolve>    end loop genc5sym 
 CNSsolve> 
 CNSsolve>  end loop c5symloop 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  noe 
 CNSsolve>    potential  symm symmetry 
 CNSsolve>    scale      symm $Data.ksym 
 CNSsolve>    sqconstant symm 1.0 
 CNSsolve>    sqexponent symm 2 
 CNSsolve>    soexponent symm 1 
 CNSsolve>    rswitch    symm 0.5 
 CNSsolve>    sqoffset   symm 0.0 
 CNSsolve>    asymptote  symm 1.0 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve>  flag incl noe end 
 CNSsolve>  noe 
 CNSsolve>    scale symm $Data.ksym 
 CNSsolve>  end 
 CNSsolve>  energy end 
 CNSsolve>  evaluate ($esym = $noe) 
 CNSsolve>  noe reset end 
 CNSsolve> 
 CNSsolve>{* ===================== calculate complex internal energy *} 
 CNSsolve>  evaluate ($kinter = 1.0) 
 CNSsolve>  @scale_intra_only.cns 
 ASSFIL: file scale_intra_only.cns opened.
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1) (segid $Toppar.prot_segid_$nchain1) weight * 1.0 end 
 CNSsolve> 
 CNSsolve> end loop nloop1 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve>  energy end 
 CNSsolve>  evaluate ($eintcplx = $bond + $angl + $impr + $dihe + $vdw + $elec) 
 CNSsolve> 
 CNSsolve>{* ===================== calculate final energies and write structure *} 
 CNSsolve>  flag exclude * include elec vdw end 
 CNSsolve>  evaluate ($kinter = 1.0) 
 CNSsolve>  @scale_inter_only.cns 
 ASSFIL: file scale_inter_only.cns opened.
 CNSsolve>igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2) weight * 1.0 vdw $kinter elec $kinter end 
 CNSsolve>    end loop nloop2 
 CNSsolve> 
 CNSsolve> end loop nloop1 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve>  energy end 
 CNSsolve>  evaluate ($etot = $ener) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  do (q=1.0) (all) 
 CNSsolve>  do (b=10) (all) 
 CNSsolve>  @print_coorheader.cns 
 ASSFIL: file print_coorheader.cns opened.
 CNSsolve>!$Revision: 1.3 $ 
 CNSsolve>!$Date: 2004/06/17 08:40:54 $ 
 CNSsolve>!$RCSfile: print_coorheader.cns,v $ 
 CNSsolve> 
 CNSsolve>! print_coorheader.cns 
 CNSsolve>!     ************************************ 
 CNSsolve>!     * Authors and copyright:           * 
 CNSsolve>!     * Michael Nilges, Jens Linge, EMBL * 
 CNSsolve>!     * Adapted by Alexandre Bonvin      * 
 CNSsolve>!     * Utrecht University               * 
 CNSsolve>!     * No warranty implied or expressed * 
 CNSsolve>!     * All rights reserved              * 
 CNSsolve>!     ************************************ 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($Data.flags.dihed eq FALSE) then evaluate ($dihe = 0) end if 
 CNSsolve>if ($Data.flags.sani  eq FALSE) then evaluate ($sani = 0) end if 
 CNSsolve>if ($Data.flags.dani  eq FALSE) then evaluate ($dani = 0) end if 
 CNSsolve>if ($Data.flags.coup  eq FALSE) then evaluate ($coup = 0) end if 
 CNSsolve>if ($Data.flags.vean  eq FALSE) then evaluate ($vean = 0) end if 
 CNSsolve>if ($Data.flags.cdih  eq FALSE) then evaluate ($cdih = 0) end if 
 CNSsolve>if ($Data.flags.noe   eq FALSE) then evaluate ($noe  = 0) end if 
 CNSsolve> 
 CNSsolve>evaluate($enerall=$etot) 
 CNSsolve>evaluate($bondall=$bond) 
 CNSsolve>evaluate($anglall=$angl) 
 CNSsolve>evaluate($imprall=$impr) 
 CNSsolve>evaluate($diheall=$dihe) 
 CNSsolve>evaluate($vdwall=$vdw) 
 CNSsolve>evaluate($elecall=$elec) 
 CNSsolve>evaluate($noeall=$noe) 
 CNSsolve>evaluate($cdihall=$cdih) 
 CNSsolve>evaluate($coupall=$coup) 
 CNSsolve>evaluate($saniall=$sani) 
 CNSsolve>evaluate($veanall=$vean) 
 CNSsolve>evaluate($daniall=$dani) 
 CNSsolve> 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>print threshold=0.3 noe 
 CNSsolve>evaluate ($rms_noe=$result) 
 CNSsolve>evaluate ($violations_noe=$violations) 
 CNSsolve> 
 CNSsolve>if ($Data.noecv eq false) then 
 CNSsolve>  evaluate ($violations_test_noe= 0) 
 CNSsolve>  evaluate ($rms_test_noe = 0) 
 CNSsolve>  evaluate ($npart = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>print threshold=5. cdih 
 CNSsolve>evaluate ($rms_cdih=$result) 
 CNSsolve>evaluate ($violations_cdih=$violations) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>print thres=0.05 bonds 
 CNSsolve>evaluate ($rms_bonds=$result) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>print thres=5. angles 
 CNSsolve>evaluate ($rms_angles=$result) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>print thres=5. impropers 
 CNSsolve>evaluate ($rms_impropers=$result) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>print thres=30. dihedrals 
 CNSsolve>evaluate ($rms_dihedrals=$result) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>coupl print thres=1.0 class * end 
 CNSsolve>evaluate ($rms_coup = $result) 
 CNSsolve>evaluate ($violations_coup = $violations) 
 CNSsolve> 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>sani print threshold = 0.20 class rdc1 end 
 CNSsolve>evaluate( $rms_sani = $result) 
 CNSsolve>evaluate( $violations_sani = $violations) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>sani print threshold = 0.20 class rdc2 end 
 CNSsolve>if ($result > 0) then 
 CNSsolve>  evaluate( $rms_sani = (0.5 * $rms_sani) + (0.5 * $result)) 
 CNSsolve>end if 
 CNSsolve>evaluate( $violations_sani = $violations_sani + $violations) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>sani print threshold = 0.20 class rdc3 end 
 CNSsolve>if ($result > 0) then 
 CNSsolve>  evaluate( $rms_sani = (0.5 * $rms_sani) + (0.5 * $result)) 
 CNSsolve>end if 
 CNSsolve>evaluate( $violations_sani = $violations_sani + $violations) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>sani print threshold = 0.20 class rdc4 end 
 CNSsolve>if ($result > 0) then 
 CNSsolve>  evaluate( $rms_sani = (0.5 * $rms_sani) + (0.5 * $result)) 
 CNSsolve>end if 
 CNSsolve>evaluate( $violations_sani = $violations_sani + $violations) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>sani print threshold = 0.20 class rdc5 end 
 CNSsolve>if ($result > 0) then 
 CNSsolve>  evaluate( $rms_sani = (0.5 * $rms_sani) + (0.5 * $result)) 
 CNSsolve>end if 
 CNSsolve>evaluate( $violations_sani = $violations_sani + $violations) 
 CNSsolve> 
 CNSsolve>if ($Data.flags.vean  eq TRUE) then 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  vean print threshold = 5.00 class vea1 end 
 CNSsolve>  evaluate( $rms_vean = $result) 
 CNSsolve>  evaluate( $violations_vean = $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  vean print threshold = 5.00 class vea2 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_vean = (0.5 * $rms_vean) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_vean = $violations_vean + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  vean print threshold = 5.00 class vea3 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_vean = (0.5 * $rms_vean) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_vean = $violations_vean + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  vean print threshold = 5.00 class vea4 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_vean = (0.5 * $rms_vean) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_vean = $violations_vean + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  vean print threshold = 5.00 class vea5 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_vean = (0.5 * $rms_vean) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_vean = $violations_vean + $violations) 
 CNSsolve>else 
 CNSsolve>  evaluate( $rms_vean = 0) 
 CNSsolve>  evaluate( $violations_vean = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($Data.flags.dani  eq TRUE) then 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  dani print threshold = 0.20 class dan1 end 
 CNSsolve>  evaluate( $rms_dani = $result) 
 CNSsolve>  evaluate( $violations_dani = $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  dani print threshold = 0.20 class dan2 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_dani = (0.5 * $rms_dani) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_dani = $violations_dani + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  dani print threshold = 0.20 class dan3 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_dani = (0.5 * $rms_dani) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_dani = $violations_dani + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  dani print threshold = 0.20 class dan4 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_dani = (0.5 * $rms_dani) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_dani = $violations_dani + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  dani print threshold = 0.20 class dan5 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_dani = (0.5 * $rms_dani) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_dani = $violations_dani + $violations) 
 CNSsolve>else 
 CNSsolve>  evaluate( $rms_dani = 0) 
 CNSsolve>  evaluate( $violations_dani = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>{====>} {* define ASA-based solvation parameters *} 
 CNSsolve>inline @def_solv_param.cns 
 ASSFIL: file def_solv_param.cns opened.
 CNSsolve>! 
 CNSsolve>! Define atomic solvation parameters taken from Fernandez-Recia et al. JMB 335:843 (2004) 
 CNSsolve>! 
 CNSsolve>evaluate ($arofac = 6.26) 
 CNSsolve>evaluate ($alifac = 1.27) 
 CNSsolve>evaluate ($polfac = 2.30) 
 CNSsolve>do (store1 =  0.0000) (all) 
 CNSsolve>do (store1 =  0.0151 * $alifac) (name C*) 
 CNSsolve>do (store1 =  0.0176 * $arofac) ((name CG* or name CD* or name CE* or name CH* or name CZ*) and (resn PHE or resn TYR or resn HIS or resn TRP)) 
 CNSsolve>do (store1 = -0.0170 * $polfac) (name N*) 
 CNSsolve>do (store1 = -0.0548 * $polfac) (name NT* or (name NZ* and resn LYS)) 
 CNSsolve>do (store1 = -0.0273 * $polfac) (name NH* and resn ARG) 
 CNSsolve>do (store1 = -0.0136 * $polfac) (name O*) 
 CNSsolve>do (store1 = -0.0185 * $polfac) (name OG* or name OH) 
 CNSsolve>do (store1 = -0.0299 * $polfac) ((name OD* and resn ASP) or (name OE* and resn GLU)) 
 CNSsolve>do (store1 =  0.0112 * $polfac) (name S*) 
 CNSsolve>do (store1 =  0.0022 * $polfac) ((name S* and attr charge = -0.3) or (name SD and resn MET)) 
 CNSsolve> 
 CNSsolve>{====>} {* buried surface area *} 
 CNSsolve>evaluate ($nchain1 = 1) 
 CNSsolve>evaluate ($saafree = 0) 
 CNSsolve>while ($nchain1 <= $data.ncomponents) loop nloop1 
 CNSsolve>  {====>} {* buried surface area *} 
 CNSsolve>  do (rmsd = 0) (all) 
 CNSsolve>  surface mode=access accu=0.075 rh2o=1.4 sele=(segid $Toppar.prot_segid_$nchain1 and not (resn TIP3 or resn DMS)) end 
 CNSsolve>  show sum (rmsd) (segid $Toppar.prot_segid_$nchain1 and not (resn TIP3 or resn DMS)) 
 CNSsolve>  evaluate ($saafree = $saafree + $result) 
 CNSsolve>  evaluate ($nchain1 = $nchain1 + 1) 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>do (rmsd = 0) (all) 
 CNSsolve>do (store2 = 0) (all) 
 CNSsolve>surface mode=access accu=0.075 rh2o=1.4 sele=(not (resn TIP3 or resn DMS)) end 
 CNSsolve>show sum (rmsd) (not (resn TIP3 or resn DMS)) 
 CNSsolve>evaluate ($satot = $result) 
 CNSsolve>do (store2 = rmsd * store1) (not (resn TIP3 or resn DMS)) 
 CNSsolve>show sum (store2) (not (resn TIP3 or resn DMS)) 
 CNSsolve>evaluate ($esolcplx = $result) 
 CNSsolve>evaluate ($saburied = $saafree - $satot) 
 CNSsolve>evaluate ($edesolv = $esolcplx - $esolfree) 
 CNSsolve>evaluate ($dhbinding = $edesolv + $eintcplx - $eintfree + $elec + $vdw) 
 CNSsolve>display COMPLEX dH OF BINDING = $dhbinding 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sym eq true) then 
 CNSsolve>  evaluate ($enerall = $enerall + $esym) 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.ncs eq true) then 
 CNSsolve>  evaluate ($enerall = $enerall + $ncs) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($data.waterdock eq true) then 
 CNSsolve>  ident (store3) (not all) 
 CNSsolve>  flag exclude * include vdw elec  end 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    igroup 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1) (resn TIP3 and not store3) weight * 1.0 end 
 CNSsolve>      interaction (not segid $Toppar.prot_segid_$nchain1) (resn TIP3) weight * 0.0 end 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1) (not (resn TIP3 and store3)) weight * 0.0 end 
 CNSsolve>    end 
 CNSsolve>    energy end 
 CNSsolve>    evaluate ($ener_water_$nchain1 = $ener) 
 CNSsolve>    evaluate ($enerall = $enerall + $ener) 
 CNSsolve>    evaluate ($vdw_water_$nchain1 = $vdw) 
 CNSsolve>    evaluate ($elec_water_$nchain1 = $elec) 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve>  if ($data.ncomponents < 6) then 
 CNSsolve>    eval($nchain1 = $data.ncomponents) 
 CNSsolve>    while ($nchain1 < 6) loop nloop1 
 CNSsolve>      eval($nchain1 = $nchain1 + 1) 
 CNSsolve>      evaluate ($ener_water_$nchain1 = 0.0) 
 CNSsolve>      evaluate ($vdw_water_$nchain1 = 0.0) 
 CNSsolve>      evaluate ($elec_water_$nchain1 = 0.0) 
 CNSsolve>    end loop nloop1 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  igroup 
 CNSsolve>    while ($nchain1 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain1 = $nchain1 + 1) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1) (all) weight * 0.0 end 
 CNSsolve>    end loop nloop2 
 CNSsolve>    interaction (resn TIP3 and not store3) (resn TIP3 and not store3)  weight * 1.0 end 
 CNSsolve>    interaction (store3) (store3)  weight * 0.0 end 
 CNSsolve>  end 
 CNSsolve>  energy end 
 CNSsolve>  evaluate ($ener_water_water = $ener) 
 CNSsolve>  evaluate ($enerall = $enerall + $ener) 
 CNSsolve>  evaluate ($vdw_water_water = $vdw) 
 CNSsolve>  evaluate ($elec_water_water = $elec) 
 CNSsolve>else 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < 6) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    evaluate ($ener_water_$nchain1 = 0.0) 
 CNSsolve>    evaluate ($vdw_water_$nchain1 = 0.0) 
 CNSsolve>    evaluate ($elec_water_$nchain1 = 0.0) 
 CNSsolve>  end loop nloop1 
 CNSsolve>  evaluate ($ener_water_water = 0.0) 
 CNSsolve>  evaluate ($vdw_water_water = 0.0) 
 CNSsolve>  evaluate ($elec_water_water = 0.0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks HADDOCK run for $filename 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks            total,bonds,angles,improper,dihe,vdw,elec,noe,cdih,coup,sani,vean,dani 
 CNSsolve>remarks energies: $enerall, $bondall, $anglall, $imprall, $diheall, $vdwall, $elecall, $noeall, $cdihall, $coupall, $saniall, $veanall, $daniall 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks            bonds,angles,impropers,dihe,noe,cdih,coup,sani,vean,dani 
 CNSsolve>remarks rms-dev.: $rms_bonds,$rms_angles,$rms_impropers,$rms_dihedrals,$rms_noe,$rms_cdih,$rms_coup, $rms_sani, $rms_vean, $rms_dani 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks               noe,cdih,coup,sani,vean,dani 
 CNSsolve>remarks               >0.3,>5,>1,>0,>5,>0.2 
 CNSsolve>remarks violations.: $violations_noe, $violations_cdih, $violations_coup, $violations_sani, $violations_vean, $violations_dani 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks                        CVpartition#,violations,rms 
 CNSsolve>remarks AIRs cross-validation: $npart, $violations_test_noe, $rms_test_noe 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks NCS energy: $ncs 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks Symmetry energy: $esym 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks Desolvation energy: $edesolv 
 CNSsolve>remarks Internal energy free molecules: $eintfree 
 CNSsolve>remarks Internal energy complex: $eintcplx 
 CNSsolve>remarks Binding energy: $dhbinding 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks buried surface area: $saburied 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks water - chain1: $ener_water_1 $vdw_water_1 $elec_water_1 
 CNSsolve>remarks water - chain2: $ener_water_2 $vdw_water_2 $elec_water_2 
 CNSsolve>remarks water - chain3: $ener_water_3 $vdw_water_3 $elec_water_3 
 CNSsolve>remarks water - chain4: $ener_water_4 $vdw_water_4 $elec_water_4 
 CNSsolve>remarks water - chain5: $ener_water_5 $vdw_water_5 $elec_water_5 
 CNSsolve>remarks water - chain6: $ener_water_6 $vdw_water_6 $elec_water_6 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks water - water: $ener_water_water $vdw_water_water $elec_water_water 
 CNSsolve>remarks =============================================================== 
 CNSsolve>  coor sele= (segid $Toppar.prot_segid_1) orient end 
 CNSsolve>  write coordinates sele= (all) output =$filename end 
 CNSsolve>  write structure output =$psfname end 
 CNSsolve> 
 CNSsolve>  end if 
 CNSsolve>end loop readpdb 
 CNSsolve>for $file in (  
 FOR-clause"decoy_1.pdb" 
 FOR-clause 
 FOR-clause ) loop readpdb 
 CNSsolve>!original: for $file in ( @@$filelist ) loop readpdb 
 CNSsolve>  eval($count=$count+1) 
 CNSsolve>  evaluate ($filename= $file - ".pdb" + "_conv.pdb") 
 CNSsolve>  evaluate ($psfname= $file - ".pdb" + "_conv.psf") 
 CNSsolve> 
 CNSsolve>  fileexist $filename end 
 CNSsolve>  evaluate ($convfileexist=$result) 
 CNSsolve>  if ($convfileexist eq false) then 
 CNSsolve>  dele sele=(all) end 
 CNSsolve>  struc reset end 
 CNSsolve>  noe reset end 
 CNSsolve> 
 CNSsolve>  segment 
 CNSsolve>    chain 
 CNSsolve>      convert=true 
 CNSsolve>      separate=true 
 CNSsolve>      @@$link_file 
 CNSsolve>      coordinates @@$file 
 CNSsolve>    end 
 CNSsolve>  end 
 CNSsolve>  do (name="CD1") (resname ILE and name CD) 
 CNSsolve>  do (name="O") (name OT1) 
 CNSsolve>  do (name="OXT") (name OT2) 
 CNSsolve>  delete sele=(hydrogen and attr charge = 0) end 
 CNSsolve> 
 CNSsolve>  coordinates @@$file 
 CNSsolve> 
 CNSsolve>  show sum(1) ( not(hydrogen) and not(known) ) 
 CNSsolve>  if ( $select = 0 ) then 
 CNSsolve>    display  %INFO: There are no coordinates missing for non-hydrogen atoms 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ( $log_level = verbose ) then 
 CNSsolve>    set message=normal echo=on end 
 CNSsolve>  else 
 CNSsolve>    set message=off echo=off end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ( $auto_break = true ) then 
 CNSsolve>    display test: autobreak 
 CNSsolve>    evaluate ($break=0) 
 CNSsolve> 
 CNSsolve>    for $id1 in id ( name C and bondedto(name CA) and bondedto(name O) ) loop break 
 CNSsolve> 
 CNSsolve>      show (segid) (id $id1) 
 CNSsolve>      evaluate ($segid1=$result) 
 CNSsolve>      show (resid) (id $id1) 
 CNSsolve>      evaluate ($resid1=$result) 
 CNSsolve>      show (resname) (id $id1) 
 CNSsolve>      evaluate ($resname1=$result) 
 CNSsolve> 
 CNSsolve>      show sum(1) (id $id1 and known) 
 CNSsolve>      if ( $result = 0 ) then 
 CNSsolve>        display unknown coordinates for segid $segid1 resname $resname1 resid $resid1 name C 
 CNSsolve>        display this coordinate must be known for automatic chain break detection 
 CNSsolve>        abort 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      identity (store1) ( name N and bondedto( segid $segid1 and resid $resid1 and name c ) ) 
 CNSsolve> 
 CNSsolve>      if ( $select = 1 ) then 
 CNSsolve>        show element (store1) (attribute store1 > 0) 
 CNSsolve>        evaluate ($id2=$result) 
 CNSsolve>        show (segid) (id $id2) 
 CNSsolve>        evaluate ($segid2=$result) 
 CNSsolve>        show (resid) (id $id2) 
 CNSsolve>        evaluate ($resid2=$result) 
 CNSsolve>        show (resname) (id $id2) 
 CNSsolve>        evaluate ($resname2=$result) 
 CNSsolve> 
 CNSsolve>        show sum(1) (id $id2 and known) 
 CNSsolve>        if ( $result = 0 ) then 
 CNSsolve>          display unknown coordinates for segid $segid2 resname $resname2 resid $resid2 name N 
 CNSsolve>          display this coordinate must be known for automatic chain break detection 
 CNSsolve>          abort 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        pick bond 
 CNSsolve>          (name c and segid $segid1 and resid $resid1) 
 CNSsolve>          (name n and segid $segid2 and resid $resid2) 
 CNSsolve>          geometry 
 CNSsolve> 
 CNSsolve>        if ( $result > $break_cutoff ) then 
 CNSsolve>          evaluate ($break=$break+1) 
 CNSsolve>          evaluate ($seg1.$break=$segid1) 
 CNSsolve>          evaluate ($res1.$break=$resid1) 
 CNSsolve>          evaluate ($seg2.$break=$segid2) 
 CNSsolve>          evaluate ($res2.$break=$resid2) 
 CNSsolve>          if ( $resname2 = PRO ) then 
 CNSsolve>            evaluate ($patch.$break=DPPP) 
 CNSsolve>          elseif ( $resname2 = CPR ) then 
 CNSsolve>            evaluate ($patch.$break=DPPP) 
 CNSsolve>          else 
 CNSsolve>            evaluate ($patch.$break=DPEP) 
 CNSsolve>          end if 
 CNSsolve>        end if 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>    end loop break 
 CNSsolve> 
 CNSsolve>    evaluate ($counter=1) 
 CNSsolve> 
 CNSsolve>    while ($counter <= $break) loop delete 
 CNSsolve>      patch $patch.$counter 
 CNSsolve>        reference=-=(segid $seg1.$counter and resid $res1.$counter) 
 CNSsolve>        reference=+=(segid $seg2.$counter and resid $res2.$counter) 
 CNSsolve>      end 
 CNSsolve>      evaluate ($counter=$counter+1) 
 CNSsolve>    end loop delete 
 CNSsolve> 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  eval($nchain = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain = $nchain + 1) 
 CNSsolve> 
 CNSsolve>    !for the histidine patches: 
 CNSsolve>    evaluate($hisd_counter=1) 
 CNSsolve>    while ($hisd_counter le 10) loop hisd 
 CNSsolve>      if ($Toppar.hisd_resid_$nchain_$hisd_counter > 0) then 
 CNSsolve>        show (resn) (tag and resid $Toppar.hisd_resid_$nchain_$hisd_counter) 
 CNSsolve>	if ($result eq "HIS") then 
 CNSsolve>           patch hisd reference=nil=(resid $Toppar.hisd_resid_$nchain_$hisd_counter 
 CNSsolve>	                             and segid $Toppar.prot_segid_$nchain) end 
 CNSsolve>        end if 
 CNSsolve>      end if 
 CNSsolve>      evaluate($hisd_counter=$hisd_counter + 1) 
 CNSsolve>    end loop hisd 
 CNSsolve> 
 CNSsolve>    evaluate($hise_counter=1) 
 CNSsolve>    while ($hise_counter le 10) loop hise 
 CNSsolve>      if ($Toppar.hise_resid_$nchain_$hise_counter > 0) then 
 CNSsolve>        show (resn) (tag and resid $Toppar.hise_resid_$nchain_$hise_counter) 
 CNSsolve>	if ($result eq "HIS") then 
 CNSsolve>          patch hise reference=nil=(resid $Toppar.hise_resid_$nchain_$hise_counter 
 CNSsolve>	                            and segid $Toppar.prot_segid_$nchain) end 
 CNSsolve>        end if 
 CNSsolve>      end if 
 CNSsolve>      evaluate($hise_counter=$hise_counter + 1) 
 CNSsolve>    end loop hise 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  evaluate ($disu=0) 
 CNSsolve> 
 CNSsolve>  for $id1 in id ( resname CYS and name SG ) loop dis1 
 CNSsolve>    display test: dis1 $id1 
 CNSsolve> 
 CNSsolve>    show (segid) (id $id1) 
 CNSsolve>    evaluate ($segid1=$result) 
 CNSsolve>    show (resid) (id $id1) 
 CNSsolve>    evaluate ($resid1=$result) 
 CNSsolve> 
 CNSsolve>    identity (store1) (all) 
 CNSsolve> 
 CNSsolve>    for $id2 in id ( resname CYS and name SG and 
 FOR-clause=                  ( attr store1 > $id1 ) ) loop dis2 
 CNSsolve> 
 CNSsolve>      show (segid) (id $id2) 
 CNSsolve>      evaluate ($segid2=$result) 
 CNSsolve>      show (resid) (id $id2) 
 CNSsolve>      evaluate ($resid2=$result) 
 CNSsolve> 
 CNSsolve>      pick bond (id $id1) (id $id2) geometry 
 CNSsolve> 
 CNSsolve>      if ( $result <= $disulphide_dist ) then 
 CNSsolve>        evaluate ($disu=$disu+1) 
 CNSsolve>        evaluate ($seg1.$disu=$segid1) 
 CNSsolve>        evaluate ($seg2.$disu=$segid2) 
 CNSsolve>        evaluate ($res1.$disu=$resid1) 
 CNSsolve>        evaluate ($res2.$disu=$resid2) 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>    end loop dis2 
 CNSsolve> 
 CNSsolve>  end loop dis1 
 CNSsolve> 
 CNSsolve>  evaluate ($counter=1) 
 CNSsolve>  while ( $counter <= $disu ) loop disu 
 CNSsolve>    display test: disu $counter 
 CNSsolve>    patch disu 
 CNSsolve>      reference=1=(segid $seg1.$counter and resid $res1.$counter) 
 CNSsolve>      reference=2=(segid $seg2.$counter and resid $res2.$counter) 
 CNSsolve>    end 
 CNSsolve>    evaluate ($counter=$counter+1) 
 CNSsolve>  end loop disu 
 CNSsolve> 
 CNSsolve>  for $id in id ( known and not hydrogen and name ca and resname PRO) loop cisp 
 CNSsolve> 
 CNSsolve>    show (segid) (id $id) 
 CNSsolve>    evaluate ($segid=$result) 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($resid=$result) 
 CNSsolve>    show (resname) (id $id) 
 CNSsolve>    evaluate ($resname=$result) 
 CNSsolve> 
 CNSsolve>    identity (store1) ( known and not hydrogen and ( name c and bondedto 
 CNSsolve>             ( name n and resid $resid and segid $segid ) ) ) 
 CNSsolve>    if ( $select = 1 ) then 
 CNSsolve>      show element (store1) (attribute store1 > 0) 
 CNSsolve>      evaluate ($id_prev=$result) 
 CNSsolve>      show (segid) (id $id_prev) 
 CNSsolve>      evaluate ($segid_prev=$result) 
 CNSsolve>      show (resid) (id $id_prev) 
 CNSsolve>      evaluate ($resid_prev=$result) 
 CNSsolve>      show (resname) (id $id_prev) 
 CNSsolve>      evaluate ($resname_prev=$result) 
 CNSsolve> 
 CNSsolve>      pick dihedral 
 CNSsolve>        (name ca and segid $segid_prev and resid $resid_prev) 
 CNSsolve>        (name  c and segid $segid_prev and resid $resid_prev) 
 CNSsolve>        (name  n and segid $segid and resid $resid) 
 CNSsolve>        (name ca and segid $segid and resid $resid) 
 CNSsolve>        geometry 
 CNSsolve> 
 CNSsolve>      evaluate ($dihedral=mod($result+360,360)) 
 CNSsolve> 
 CNSsolve>      if ( $dihedral > 180 ) then 
 CNSsolve>        evaluate ($dihedral=$dihedral-360) 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      evaluate ($absdihedral=abs($dihedral)) 
 CNSsolve> 
 CNSsolve>      if ( $absdihedral < 25 ) then 
 CNSsolve>        patch cisp reference=NIL=(segid $segid_prev and resid $resid_prev) end 
 CNSsolve>        display CIS peptide bon detected for residue $resid_prev 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>  end loop cisp 
 CNSsolve> 
 CNSsolve>  identity (store1) (none) 
 CNSsolve> 
 CNSsolve>  identity (store1) (not(known)) 
 CNSsolve> 
 CNSsolve>  show sum(1) (store1) 
 CNSsolve>  evaluate ($tobuild=$result) 
 CNSsolve> 
 CNSsolve>  if ( $tobuild > 0 ) then 
 CNSsolve> 
 CNSsolve>    fix selection=(not(store1)) end 
 CNSsolve> 
 CNSsolve>    show sum(1) (store1) 
 CNSsolve>    evaluate ($moving=$result) 
 CNSsolve> 
 CNSsolve>    if ( $moving > 0 ) then 
 CNSsolve>      for $id in id (tag and byres(store1)) loop avco 
 CNSsolve> 
 CNSsolve>        show ave(x) (byres(id $id) and known) 
 CNSsolve>        evaluate ($ave_x=$result) 
 CNSsolve>        show ave(y) (byres(id $id) and known) 
 CNSsolve>        evaluate ($ave_y=$result) 
 CNSsolve>        show ave(z) (byres(id $id) and known) 
 CNSsolve>        evaluate ($ave_z=$result) 
 CNSsolve> 
 CNSsolve>        do (x=$ave_x) (byres(id $id) and store1) 
 CNSsolve>        do (y=$ave_y) (byres(id $id) and store1) 
 CNSsolve>        do (z=$ave_z) (byres(id $id) and store1) 
 CNSsolve> 
 CNSsolve>      end loop avco 
 CNSsolve> 
 CNSsolve>      do (x=x+random(2.0)) (store1) 
 CNSsolve>      do (y=y+random(2.0)) (store1) 
 CNSsolve>      do (z=z+random(2.0)) (store1) 
 CNSsolve> 
 CNSsolve>      {- start parameter for the side chain building -} 
 CNSsolve>      parameter 
 CNSsolve>        nbonds 
 CNSsolve>          rcon=20. nbxmod=-2 repel=0.9  wmin=0.1 tolerance=1. 
 CNSsolve>          rexp=2 irexp=2 inhibit=0.5 
 CNSsolve>        end 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {- Friction coefficient, in 1/ps. -} 
 CNSsolve>      do (fbeta=100) (store1) 
 CNSsolve> 
 CNSsolve>      evaluate ($bath=300.0) 
 CNSsolve>      evaluate ($nstep=500) 
 CNSsolve>      evaluate ($timestep=0.0005) 
 CNSsolve> 
 CNSsolve>      do (refy=mass) (store1) 
 CNSsolve> 
 CNSsolve>      do (mass=20) (store1) 
 CNSsolve> 
 CNSsolve>      igroup interaction 
 CNSsolve>        (store1) (store1 or known) 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {- turn on initial energy terms -} 
 CNSsolve>      flags exclude * include bond angle vdw end 
 CNSsolve> 
 CNSsolve>      minimize powell nstep=50  nprint=10 end 
 CNSsolve> 
 CNSsolve>      do (vx=maxwell($bath)) (store1) 
 CNSsolve>      do (vy=maxwell($bath)) (store1) 
 CNSsolve>      do (vz=maxwell($bath)) (store1) 
 CNSsolve> 
 CNSsolve>      flags exclude vdw include impr end 
 CNSsolve> 
 CNSsolve>      dynamics cartesian 
 CNSsolve>        nstep=50 
 CNSsolve>        timestep=$timestep 
 CNSsolve>        tcoupling=true temperature=$bath 
 CNSsolve>        nprint=$nstep 
 CNSsolve>        cmremove=false 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      flags include vdw end 
 CNSsolve> 
 CNSsolve>      minimize powell nstep=50 nprint=10 end 
 CNSsolve> 
 CNSsolve>      do (vx=maxwell($bath)) (store1) 
 CNSsolve>      do (vy=maxwell($bath)) (store1) 
 CNSsolve>      do (vz=maxwell($bath)) (store1) 
 CNSsolve> 
 CNSsolve>      dynamics cartesian 
 CNSsolve>        nstep=50 
 CNSsolve>        timestep=$timestep 
 CNSsolve>        tcoupling=true temperature=$bath 
 CNSsolve>        nprint=$nstep 
 CNSsolve>        cmremove=false 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      parameter 
 CNSsolve>        nbonds 
 CNSsolve>          rcon=2. nbxmod=-3 repel=0.75 
 CNSsolve>        end 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      minimize powell nstep=100 nprint=25 end 
 CNSsolve> 
 CNSsolve>      do (vx=maxwell($bath)) (store1) 
 CNSsolve>      do (vy=maxwell($bath)) (store1) 
 CNSsolve>      do (vz=maxwell($bath)) (store1) 
 CNSsolve> 
 CNSsolve>      dynamics cartesian 
 CNSsolve>        nstep=$nstep 
 CNSsolve>        timestep=$timestep 
 CNSsolve>        tcoupling=true temperature=$bath 
 CNSsolve>        nprint=$nstep 
 CNSsolve>        cmremove=false 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {- turn on all energy terms -} 
 CNSsolve>      flags include dihe ? end 
 CNSsolve> 
 CNSsolve>      {- set repel to ~vdw radii -} 
 CNSsolve>      parameter 
 CNSsolve>        nbonds 
 CNSsolve>          repel=0.89 
 CNSsolve>        end 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      minimize powell nstep=500 nprint=50 end 
 CNSsolve> 
 CNSsolve>      flag include elec end 
 CNSsolve>      energy end 
 CNSsolve>      flags exclude * include bond angl impr dihe vdw end 
 CNSsolve> 
 CNSsolve>      {- return masses to something sensible -} 
 CNSsolve>      do (mass=refy) (store1) 
 CNSsolve> 
 CNSsolve>      do (vx=maxwell($bath)) (store1) 
 CNSsolve>      do (vy=maxwell($bath)) (store1) 
 CNSsolve>      do (vz=maxwell($bath)) (store1) 
 CNSsolve> 
 CNSsolve>      dynamics cartesian 
 CNSsolve>        nstep=$nstep 
 CNSsolve>        timestep=$timestep 
 CNSsolve>        tcoupling=true temperature=$bath 
 CNSsolve>        nprint=$nstep 
 CNSsolve>        cmremove=false 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {- some final minimisation -} 
 CNSsolve>      minimize powell 
 CNSsolve>        nstep=500 
 CNSsolve>        drop=40.0 
 CNSsolve>        nprint=50 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      print thres=0.02 bonds 
 CNSsolve>      print thres=5. angles 
 CNSsolve> 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    fix selection=( none ) end 
 CNSsolve> 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if (&set_bfactor=true) then 
 CNSsolve>    do (b=&bfactor) ( all ) 
 CNSsolve>  else 
 CNSsolve>    show ave(b) (known and not(store1)) 
 CNSsolve>    do (b=$result) (store1 and (attr b < 0.01)) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  set remarks=reset end 
 CNSsolve> 
 CNSsolve>{* ===================== turn on electrostatics *} 
 CNSsolve> 
 CNSsolve>  parameter 
 CNSsolve>    nbonds 
 CNSsolve>      nbxmod=5 atom cdie shift 
 CNSsolve>      cutnb=9.5 ctofnb=8.5 ctonnb=6.5 eps=$epsilon e14fac=0.4 inhibit 0.5 
 CNSsolve>      wmin=0.5 
 CNSsolve>      tolerance  0.5 
 CNSsolve>      repel=0.0 
 CNSsolve>    end 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  flags excl * incl bond angl impr dihe vdw elec end 
 CNSsolve> 
 CNSsolve>{* ===================== calculate free molecules internal energy *} 
 CNSsolve> 
 CNSsolve>  do (refx=x) (all) 
 CNSsolve>  do (refy=y) (all) 
 CNSsolve>  do (refz=z) (all) 
 CNSsolve>  inline  
 CNSsolve>!$Revision:$ 
 CNSsolve>!$Date:$ 
 CNSsolve>!$RCSfile:$ 
 CNSsolve>! 
 CNSsolve>!     *********************************** 
 CNSsolve>!     * Authors and copyright:           * 
 CNSsolve>!     * Alexandre Bonvin, Utrecht        * 
 CNSsolve>!     * No warranty implied or expressed * 
 CNSsolve>!     * All rights reserved              * 
 CNSsolve>!     ************************************ 
 CNSsolve> 
 CNSsolve>!move molecules far apart 
 CNSsolve> 
 CNSsolve>! module to separate the molecules in space 
 CNSsolve>! put molecules 50A away from each other 
 CNSsolve>! 
 CNSsolve>Module(Data;Toppar;) 
 CNSsolve>(Data=$Data; Toppar=$Toppar) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  evaluate ($spacing=50) 
 CNSsolve>  evaluate ($trdis=$spacing/2) 
 CNSsolve>  evaluate ($trc=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve>  evaluate ($trd=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = 0) 
 CNSsolve> 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nsloop1 
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 CNSsolve>    eval($watersegname_$ncount="WAT" + encode($ncount)) 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 CNSsolve>    do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>  end loop nsloop1 
 CNSsolve> 
 CNSsolve>  do (x = xcomp) (not (resn DAN or resn ANI)) 
 CNSsolve>  do (y = ycomp) (not (resn DAN or resn ANI)) 
 CNSsolve>  do (z = zcomp) (not (resn DAN or resn ANI)) 
 CNSsolve> 
 CNSsolve>  show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>  evaluate ($xt = -$trdis - $result ) 
 CNSsolve>  coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>  show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>  evaluate ($xt = $trdis - $result ) 
 CNSsolve>  coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>  if ($data.ncomponents>2) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = $trc - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>3) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($zt = $trd - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>4) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -($trd - $result) ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>5) then 
 CNSsolve>    evaluate ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.ncomponents) loop nsloop2 
 CNSsolve>      evaluate ($ncount = $ncount +1) 
 CNSsolve>      show ave (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($xdis=-$result) 
 CNSsolve>      show ave (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($ydis=-$result) 
 CNSsolve>      show ave (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($zdis=-$result) 
 CNSsolve>      coor trans sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) vector=($xdis,$ydis,$zdis) end 
 CNSsolve>    end loop nsloop2 
 CNSsolve> 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,0) end 
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,0,$zt) end 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_6 or segid $watersegname_6) 
 CNSsolve>    evaluate ($zt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_6 or segid $watersegname_6) vector=(0,0,$zt) end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve>  interaction (not (resname ANI or resname DAN)) (not (resname ANI or resname DAN)) 
 CNSsolve>  interaction (    resname ANI) (    resname ANI) 
 CNSsolve>  interaction (    resname DAN) (    resname DAN) 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>evaluate ($eintfree = 0.0) 
 CNSsolve>minimize powell nstep=50 drop=10.0 nprint=25 end 
 CNSsolve>param nbonds eps=1.0 end end 
 CNSsolve>energy end 
 CNSsolve>evaluate ($eintfree = $bond + $angl + $impr + $dihe + $vdw + $elec) 
 CNSsolve> 
 CNSsolve>display FREE MOLECULES INTERNAL ENERGY = $eintfree 
 CNSsolve> 
 CNSsolve>{====>} {* define ASA-based solvation parameters *} 
 CNSsolve>inline  
 CNSsolve>! 
 CNSsolve>! Define atomic solvation parameters taken from Fernandez-Recia et al. JMB 335:843 (2004) 
 CNSsolve>! 
 CNSsolve>evaluate ($arofac = 6.26) 
 CNSsolve>evaluate ($alifac = 1.27) 
 CNSsolve>evaluate ($polfac = 2.30) 
 CNSsolve>do (store1 =  0.0000) (all) 
 CNSsolve>do (store1 =  0.0151 * $alifac) (name C*) 
 CNSsolve>do (store1 =  0.0176 * $arofac) ((name CG* or name CD* or name CE* or name CH* or name CZ*) and (resn PHE or resn TYR or resn HIS or resn TRP)) 
 CNSsolve>do (store1 = -0.0170 * $polfac) (name N*) 
 CNSsolve>do (store1 = -0.0548 * $polfac) (name NT* or (name NZ* and resn LYS)) 
 CNSsolve>do (store1 = -0.0273 * $polfac) (name NH* and resn ARG) 
 CNSsolve>do (store1 = -0.0136 * $polfac) (name O*) 
 CNSsolve>do (store1 = -0.0185 * $polfac) (name OG* or name OH) 
 CNSsolve>do (store1 = -0.0299 * $polfac) ((name OD* and resn ASP) or (name OE* and resn GLU)) 
 CNSsolve>do (store1 =  0.0112 * $polfac) (name S*) 
 CNSsolve>do (store1 =  0.0022 * $polfac) ((name S* and attr charge = -0.3) or (name SD and resn MET)) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>{====>} {* buried surface area *} 
 CNSsolve>evaluate ($esolfree = 0) 
 CNSsolve>evaluate ($nchain1 = 1) 
 CNSsolve>evaluate ($saafree = 0) 
 CNSsolve>while ($nchain1 <= $data.ncomponents) loop nloop1 
 CNSsolve>  coor orient sele=(segid $Toppar.prot_segid_$nchain1 and not (resn TIP3 or resn DMS)) end 
 CNSsolve>  {====>} {* buried surface area *} 
 CNSsolve>  do (rmsd = 0) (all) 
 CNSsolve>  do (store2 = 0) (all) 
 CNSsolve>  surface mode=access accu=0.075 rh2o=1.4 sele=(segid $Toppar.prot_segid_$nchain1 and not (resn TIP3 or resn DMS)) end 
 CNSsolve>  show sum (rmsd) (segid $Toppar.prot_segid_$nchain1 and not (resn TIP3 or resn DMS)) 
 CNSsolve>  evaluate ($saafree = $saafree + $result) 
 CNSsolve>  do (store2 = rmsd * store1) (segid $Toppar.prot_segid_$nchain1 and not (resn TIP3 or resn DMS)) 
 CNSsolve>  show sum (store2) (segid $Toppar.prot_segid_$nchain1 and not (resn TIP3 or resn DMS)) 
 CNSsolve>  evaluate ($esolfree = $esolfree + $result) 
 CNSsolve>  evaluate ($nchain1 = $nchain1 + 1) 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  do (x=refx) (all) 
 CNSsolve>  do (y=refy) (all) 
 CNSsolve>  do (z=refz) (all) 
 CNSsolve> 
 CNSsolve>{* ===================== minimize complex *} 
 CNSsolve> 
 CNSsolve>  parameter nbonds eps=$epsilon end end 
 CNSsolve> 
 CNSsolve>!  fix selection=(not(store1)) end 
 CNSsolve>  fix selection=(segid B or (name P or name N1 or name CA or name C or name N or name O)) end 
 CNSsolve>  minimize powell 
 CNSsolve>    nstep=50 
 CNSsolve>    drop=40.0 
 CNSsolve>    nprint=50 
 CNSsolve>  end 
 CNSsolve>  fix selection=(not all) end 
 CNSsolve> 
 CNSsolve>  parameter nbonds eps=1.0 end end 
 CNSsolve> 
 CNSsolve>{* ===================== calculate symmetry energy *} 
 CNSsolve> 
 CNSsolve>  noe reset nres=10000 end 
 CNSsolve>   
 CNSsolve>!$Revision: 1.0 $ 
 CNSsolve>!$Date: 2003/02/19 08:14:08 $ 
 CNSsolve>!$RCSfile: symdimer.cns,v $ 
 CNSsolve> 
 CNSsolve>! Define NCS restraints for symmetrical multimers 
 CNSsolve>if ($Data.flags.ncs eq true) then 
 CNSsolve> 
 CNSsolve>  ncs restraints 
 CNSsolve>    initialize 
 CNSsolve>    eval ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.numncs) loop ncsloop 
 CNSsolve>      eval ($ncount = $ncount + 1) 
 CNSsolve>      group 
 CNSsolve>        equi (resid $Toppar.ncs_sta1_$ncount : $Toppar.ncs_end1_$ncount and segid $Toppar.ncs_seg1_$ncount) 
 CNSsolve>        equi (resid $Toppar.ncs_sta2_$ncount : $Toppar.ncs_end2_$ncount and segid $Toppar.ncs_seg2_$ncount) 
 CNSsolve>	weight = $Data.kncs 
 CNSsolve>      end 
 CNSsolve>    end loop ncsloop 
 CNSsolve>    ? 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>! Define C2 symmetry restraints for symmetrical multimers 
 CNSsolve>! 
 CNSsolve>if ($Data.flags.sym eq true) then 
 CNSsolve> 
 CNSsolve>  noe class symm end 
 CNSsolve> 
 CNSsolve>  eval ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.numc2sym) loop c2symloop 
 CNSsolve> 
 CNSsolve>    eval ($ncount = $ncount + 1) 
 CNSsolve>    evaluate ($i1start = decode($Toppar.c2sym_sta1_$ncount)) 
 CNSsolve>    evaluate ($i1end   = decode($Toppar.c2sym_end1_$ncount)) 
 CNSsolve>    evaluate ($chain1  = $Toppar.c2sym_seg1_$ncount) 
 CNSsolve>    evaluate ($i2start = decode($Toppar.c2sym_sta2_$ncount)) 
 CNSsolve>    evaluate ($i2end   = decode($Toppar.c2sym_end2_$ncount)) 
 CNSsolve>    evaluate ($chain2  = $Toppar.c2sym_seg2_$ncount) 
 CNSsolve> 
 CNSsolve>    !first check that the chain lengths are equal for the two defined molecules 
 CNSsolve>    evaluate ($diff1 = $i1end - $i1start) 
 CNSsolve>    evaluate ($diff2 = $i2end - $i2start) 
 CNSsolve>    if ($diff1 ne $diff2) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    eval ($icount = 0) 
 CNSsolve>    while ($i1start < $i1end) loop genc2sym 
 CNSsolve> 
 CNSsolve>      evaluate ($resid1 = $i1start) 
 CNSsolve>      evaluate ($resid2 = $i2end - $icount) 
 CNSsolve>      evaluate ($resid3 = $i2start) 
 CNSsolve>      evaluate ($resid4 = $i1end - $icount) 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve>	assign (resid $resid1 and name CA  and segid $chain1) 
 CNSsolve>	       (resid $resid2 and name CA  and segid $chain2) 0 0 0 
 CNSsolve>	assign (resid $resid3 and name CA  and segid $chain2) 
 CNSsolve>	       (resid $resid4 and name CA  and segid $chain1) 0 0 0 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($icount = $icount + 1) 
 CNSsolve>      evaluate ($i1start = $i1start + 1) 
 CNSsolve>      evaluate ($i2start = $i2start + 1) 
 CNSsolve> 
 CNSsolve>    end loop genc2sym 
 CNSsolve> 
 CNSsolve>  end loop c2symloop 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>! Define C3 symmetry restraints for symmetrical multimers 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>  eval ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.numc3sym) loop c3symloop 
 CNSsolve> 
 CNSsolve>    eval ($ncount = $ncount + 1) 
 CNSsolve>    evaluate ($i1start = decode($Toppar.c3sym_sta1_$ncount)) 
 CNSsolve>    evaluate ($i1end   = decode($Toppar.c3sym_end1_$ncount)) 
 CNSsolve>    evaluate ($chain1  = $Toppar.c3sym_seg1_$ncount) 
 CNSsolve>    evaluate ($i2start = decode($Toppar.c3sym_sta2_$ncount)) 
 CNSsolve>    evaluate ($i2end   = decode($Toppar.c3sym_end2_$ncount)) 
 CNSsolve>    evaluate ($chain2  = $Toppar.c3sym_seg2_$ncount) 
 CNSsolve>    evaluate ($i3start = decode($Toppar.c3sym_sta3_$ncount)) 
 CNSsolve>    evaluate ($i3end   = decode($Toppar.c3sym_end3_$ncount)) 
 CNSsolve>    evaluate ($chain3  = $Toppar.c3sym_seg3_$ncount) 
 CNSsolve> 
 CNSsolve>    !first check that the chain lengths are equal for the two defined molecules 
 CNSsolve>    evaluate ($diff1 = $i1end - $i1start) 
 CNSsolve>    evaluate ($diff2 = $i2end - $i2start) 
 CNSsolve>    evaluate ($diff3 = $i3end - $i3start) 
 CNSsolve>    if ($diff1 ne $diff2) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff1 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff2 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    eval ($icount = 0) 
 CNSsolve>    while ($i1start < $i1end) loop genc3sym 
 CNSsolve> 
 CNSsolve>      evaluate ($resst1 = $i1start) 
 CNSsolve>      evaluate ($resst2 = $i2start) 
 CNSsolve>      evaluate ($resst3 = $i3start) 
 CNSsolve>      evaluate ($resen1 = $i1end - $icount) 
 CNSsolve>      evaluate ($resen2 = $i2end - $icount) 
 CNSsolve>      evaluate ($resen3 = $i3end - $icount) 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve> 
 CNSsolve>         assign (resid $resst1 and name CA  and segid $chain1) 
 CNSsolve>                (resid $resen2 and name CA  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst2 and name CA  and segid $chain2) 
 CNSsolve>                (resid $resen3 and name CA  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and name CA  and segid $chain2) 
 CNSsolve>                (resid $resen3 and name CA  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst3 and name CA  and segid $chain3) 
 CNSsolve>                (resid $resen1 and name CA  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and name CA  and segid $chain3) 
 CNSsolve>                (resid $resen1 and name CA  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resst1 and name CA  and segid $chain1) 
 CNSsolve>                (resid $resen2 and name CA  and segid $chain2) 0 0 0 
 CNSsolve> 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($icount = $icount + 2) 
 CNSsolve>      evaluate ($i1start = $i1start + 2) 
 CNSsolve>      evaluate ($i2start = $i2start + 2) 
 CNSsolve>      evaluate ($i3start = $i3start + 2) 
 CNSsolve> 
 CNSsolve>    end loop genc3sym 
 CNSsolve> 
 CNSsolve>  end loop c3symloop 
 CNSsolve> 
 CNSsolve>! Define C5 symmetry restraints for symmetrical multimers 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>  eval ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.numc5sym) loop c5symloop 
 CNSsolve> 
 CNSsolve>    eval ($ncount = $ncount + 1) 
 CNSsolve>    evaluate ($i1start = decode($Toppar.c5sym_sta1_$ncount)) 
 CNSsolve>    evaluate ($i1end   = decode($Toppar.c5sym_end1_$ncount)) 
 CNSsolve>    evaluate ($chain1  = $Toppar.c5sym_seg1_$ncount) 
 CNSsolve>    evaluate ($i2start = decode($Toppar.c5sym_sta2_$ncount)) 
 CNSsolve>    evaluate ($i2end   = decode($Toppar.c5sym_end2_$ncount)) 
 CNSsolve>    evaluate ($chain2  = $Toppar.c5sym_seg2_$ncount) 
 CNSsolve>    evaluate ($i3start = decode($Toppar.c5sym_sta3_$ncount)) 
 CNSsolve>    evaluate ($i3end   = decode($Toppar.c5sym_end3_$ncount)) 
 CNSsolve>    evaluate ($chain3  = $Toppar.c5sym_seg3_$ncount) 
 CNSsolve>    evaluate ($i4start = decode($Toppar.c5sym_sta4_$ncount)) 
 CNSsolve>    evaluate ($i4end   = decode($Toppar.c5sym_end4_$ncount)) 
 CNSsolve>    evaluate ($chain4  = $Toppar.c5sym_seg4_$ncount) 
 CNSsolve>    evaluate ($i5start = decode($Toppar.c5sym_sta5_$ncount)) 
 CNSsolve>    evaluate ($i5end   = decode($Toppar.c5sym_end5_$ncount)) 
 CNSsolve>    evaluate ($chain5  = $Toppar.c5sym_seg5_$ncount) 
 CNSsolve> 
 CNSsolve>    !first check that the chain lengths are equal for the two defined molecules 
 CNSsolve>    evaluate ($diff1 = $i1end - $i1start) 
 CNSsolve>    evaluate ($diff2 = $i2end - $i2start) 
 CNSsolve>    evaluate ($diff3 = $i3end - $i3start) 
 CNSsolve>    evaluate ($diff4 = $i4end - $i4start) 
 CNSsolve>    evaluate ($diff5 = $i5end - $i5start) 
 CNSsolve>    if ($diff1 ne $diff2) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff1 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff2 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff3 ne $diff4) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff4 ne $diff5) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    eval ($icount = 0) 
 CNSsolve>    while ($i1start < $i1end) loop genc5sym 
 CNSsolve> 
 CNSsolve>      evaluate ($resst1 = $i1start) 
 CNSsolve>      evaluate ($resst2 = $i2start) 
 CNSsolve>      evaluate ($resst3 = $i3start) 
 CNSsolve>      evaluate ($resst4 = $i4start) 
 CNSsolve>      evaluate ($resst5 = $i5start) 
 CNSsolve>      evaluate ($resen1 = $i1end - $icount) 
 CNSsolve>      evaluate ($resen2 = $i2end - $icount) 
 CNSsolve>      evaluate ($resen3 = $i3end - $icount) 
 CNSsolve>      evaluate ($resen4 = $i4end - $icount) 
 CNSsolve>      evaluate ($resen5 = $i5end - $icount) 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve>{ 
 CNSsolve>         assign (resid $resst1 and name CA  and segid $chain1) 
 CNSsolve>                (resid $resen2 and name CA  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst2 and name CA  and segid $chain2) 
 CNSsolve>                (resid $resen3 and name CA  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and name CA  and segid $chain2) 
 CNSsolve>                (resid $resen3 and name CA  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst3 and name CA  and segid $chain3) 
 CNSsolve>                (resid $resen4 and name CA  and segid $chain4) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and name CA  and segid $chain3) 
 CNSsolve>                (resid $resen4 and name CA  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resst4 and name CA  and segid $chain4) 
 CNSsolve>                (resid $resen5 and name CA  and segid $chain5) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst4 and name CA  and segid $chain4) 
 CNSsolve>                (resid $resen5 and name CA  and segid $chain5) 0 0 0 
 CNSsolve>         assign (resid $resst5 and name CA  and segid $chain5) 
 CNSsolve>                (resid $resen1 and name CA  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst5 and name CA  and segid $chain5) 
 CNSsolve>                (resid $resen1 and name CA  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resst1 and name CA  and segid $chain1) 
 CNSsolve>                (resid $resen2 and name CA  and segid $chain2) 0 0 0 
 CNSsolve>} 
 CNSsolve>         assign (resid $resst1 and name CA  and segid $chain1) 
 CNSsolve>                (resid $resst3 and name CA  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst1 and name CA  and segid $chain1) 
 CNSsolve>                (resid $resst4 and name CA  and segid $chain4) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and name CA  and segid $chain2) 
 CNSsolve>                (resid $resst4 and name CA  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resst2 and name CA  and segid $chain2) 
 CNSsolve>                (resid $resst5 and name CA  and segid $chain5) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and name CA  and segid $chain3) 
 CNSsolve>                (resid $resst5 and name CA  and segid $chain5) 0 0 0 
 CNSsolve>         assign (resid $resst3 and name CA  and segid $chain3) 
 CNSsolve>                (resid $resst1 and name CA  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst4 and name CA  and segid $chain4) 
 CNSsolve>                (resid $resst1 and name CA  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resst4 and name CA  and segid $chain4) 
 CNSsolve>                (resid $resst2 and name CA  and segid $chain2) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst5 and name CA  and segid $chain5) 
 CNSsolve>                (resid $resst2 and name CA  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst5 and name CA  and segid $chain5) 
 CNSsolve>                (resid $resst3 and name CA  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($icount = $icount + 2) 
 CNSsolve>      evaluate ($i1start = $i1start + 2) 
 CNSsolve>      evaluate ($i2start = $i2start + 2) 
 CNSsolve>      evaluate ($i3start = $i3start + 2) 
 CNSsolve>      evaluate ($i4start = $i4start + 2) 
 CNSsolve>      evaluate ($i5start = $i5start + 2) 
 CNSsolve> 
 CNSsolve>    end loop genc5sym 
 CNSsolve> 
 CNSsolve>  end loop c5symloop 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  noe 
 CNSsolve>    potential  symm symmetry 
 CNSsolve>    scale      symm $Data.ksym 
 CNSsolve>    sqconstant symm 1.0 
 CNSsolve>    sqexponent symm 2 
 CNSsolve>    soexponent symm 1 
 CNSsolve>    rswitch    symm 0.5 
 CNSsolve>    sqoffset   symm 0.0 
 CNSsolve>    asymptote  symm 1.0 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  flag incl noe end 
 CNSsolve>  noe 
 CNSsolve>    scale symm $Data.ksym 
 CNSsolve>  end 
 CNSsolve>  energy end 
 CNSsolve>  evaluate ($esym = $noe) 
 CNSsolve>  noe reset end 
 CNSsolve> 
 CNSsolve>{* ===================== calculate complex internal energy *} 
 CNSsolve>  evaluate ($kinter = 1.0) 
 CNSsolve>   
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1) (segid $Toppar.prot_segid_$nchain1) weight * 1.0 end 
 CNSsolve> 
 CNSsolve> end loop nloop1 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  energy end 
 CNSsolve>  evaluate ($eintcplx = $bond + $angl + $impr + $dihe + $vdw + $elec) 
 CNSsolve> 
 CNSsolve>{* ===================== calculate final energies and write structure *} 
 CNSsolve>  flag exclude * include elec vdw end 
 CNSsolve>  evaluate ($kinter = 1.0) 
 CNSsolve>   
 CNSsolve>igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2) weight * 1.0 vdw $kinter elec $kinter end 
 CNSsolve>    end loop nloop2 
 CNSsolve> 
 CNSsolve> end loop nloop1 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  energy end 
 CNSsolve>  evaluate ($etot = $ener) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  do (q=1.0) (all) 
 CNSsolve>  do (b=10) (all) 
 CNSsolve>   
 CNSsolve>!$Revision: 1.3 $ 
 CNSsolve>!$Date: 2004/06/17 08:40:54 $ 
 CNSsolve>!$RCSfile: print_coorheader.cns,v $ 
 CNSsolve> 
 CNSsolve>! print_coorheader.cns 
 CNSsolve>!     ************************************ 
 CNSsolve>!     * Authors and copyright:           * 
 CNSsolve>!     * Michael Nilges, Jens Linge, EMBL * 
 CNSsolve>!     * Adapted by Alexandre Bonvin      * 
 CNSsolve>!     * Utrecht University               * 
 CNSsolve>!     * No warranty implied or expressed * 
 CNSsolve>!     * All rights reserved              * 
 CNSsolve>!     ************************************ 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($Data.flags.dihed eq FALSE) then evaluate ($dihe = 0) end if 
 CNSsolve>if ($Data.flags.sani  eq FALSE) then evaluate ($sani = 0) end if 
 CNSsolve>if ($Data.flags.dani  eq FALSE) then evaluate ($dani = 0) end if 
 CNSsolve>if ($Data.flags.coup  eq FALSE) then evaluate ($coup = 0) end if 
 CNSsolve>if ($Data.flags.vean  eq FALSE) then evaluate ($vean = 0) end if 
 CNSsolve>if ($Data.flags.cdih  eq FALSE) then evaluate ($cdih = 0) end if 
 CNSsolve>if ($Data.flags.noe   eq FALSE) then evaluate ($noe  = 0) end if 
 CNSsolve> 
 CNSsolve>evaluate($enerall=$etot) 
 CNSsolve>evaluate($bondall=$bond) 
 CNSsolve>evaluate($anglall=$angl) 
 CNSsolve>evaluate($imprall=$impr) 
 CNSsolve>evaluate($diheall=$dihe) 
 CNSsolve>evaluate($vdwall=$vdw) 
 CNSsolve>evaluate($elecall=$elec) 
 CNSsolve>evaluate($noeall=$noe) 
 CNSsolve>evaluate($cdihall=$cdih) 
 CNSsolve>evaluate($coupall=$coup) 
 CNSsolve>evaluate($saniall=$sani) 
 CNSsolve>evaluate($veanall=$vean) 
 CNSsolve>evaluate($daniall=$dani) 
 CNSsolve> 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>print threshold=0.3 noe 
 CNSsolve>evaluate ($rms_noe=$result) 
 CNSsolve>evaluate ($violations_noe=$violations) 
 CNSsolve> 
 CNSsolve>if ($Data.noecv eq false) then 
 CNSsolve>  evaluate ($violations_test_noe= 0) 
 CNSsolve>  evaluate ($rms_test_noe = 0) 
 CNSsolve>  evaluate ($npart = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>print threshold=5. cdih 
 CNSsolve>evaluate ($rms_cdih=$result) 
 CNSsolve>evaluate ($violations_cdih=$violations) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>print thres=0.05 bonds 
 CNSsolve>evaluate ($rms_bonds=$result) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>print thres=5. angles 
 CNSsolve>evaluate ($rms_angles=$result) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>print thres=5. impropers 
 CNSsolve>evaluate ($rms_impropers=$result) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>print thres=30. dihedrals 
 CNSsolve>evaluate ($rms_dihedrals=$result) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>coupl print thres=1.0 class * end 
 CNSsolve>evaluate ($rms_coup = $result) 
 CNSsolve>evaluate ($violations_coup = $violations) 
 CNSsolve> 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>sani print threshold = 0.20 class rdc1 end 
 CNSsolve>evaluate( $rms_sani = $result) 
 CNSsolve>evaluate( $violations_sani = $violations) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>sani print threshold = 0.20 class rdc2 end 
 CNSsolve>if ($result > 0) then 
 CNSsolve>  evaluate( $rms_sani = (0.5 * $rms_sani) + (0.5 * $result)) 
 CNSsolve>end if 
 CNSsolve>evaluate( $violations_sani = $violations_sani + $violations) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>sani print threshold = 0.20 class rdc3 end 
 CNSsolve>if ($result > 0) then 
 CNSsolve>  evaluate( $rms_sani = (0.5 * $rms_sani) + (0.5 * $result)) 
 CNSsolve>end if 
 CNSsolve>evaluate( $violations_sani = $violations_sani + $violations) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>sani print threshold = 0.20 class rdc4 end 
 CNSsolve>if ($result > 0) then 
 CNSsolve>  evaluate( $rms_sani = (0.5 * $rms_sani) + (0.5 * $result)) 
 CNSsolve>end if 
 CNSsolve>evaluate( $violations_sani = $violations_sani + $violations) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>sani print threshold = 0.20 class rdc5 end 
 CNSsolve>if ($result > 0) then 
 CNSsolve>  evaluate( $rms_sani = (0.5 * $rms_sani) + (0.5 * $result)) 
 CNSsolve>end if 
 CNSsolve>evaluate( $violations_sani = $violations_sani + $violations) 
 CNSsolve> 
 CNSsolve>if ($Data.flags.vean  eq TRUE) then 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  vean print threshold = 5.00 class vea1 end 
 CNSsolve>  evaluate( $rms_vean = $result) 
 CNSsolve>  evaluate( $violations_vean = $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  vean print threshold = 5.00 class vea2 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_vean = (0.5 * $rms_vean) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_vean = $violations_vean + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  vean print threshold = 5.00 class vea3 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_vean = (0.5 * $rms_vean) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_vean = $violations_vean + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  vean print threshold = 5.00 class vea4 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_vean = (0.5 * $rms_vean) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_vean = $violations_vean + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  vean print threshold = 5.00 class vea5 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_vean = (0.5 * $rms_vean) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_vean = $violations_vean + $violations) 
 CNSsolve>else 
 CNSsolve>  evaluate( $rms_vean = 0) 
 CNSsolve>  evaluate( $violations_vean = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($Data.flags.dani  eq TRUE) then 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  dani print threshold = 0.20 class dan1 end 
 CNSsolve>  evaluate( $rms_dani = $result) 
 CNSsolve>  evaluate( $violations_dani = $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  dani print threshold = 0.20 class dan2 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_dani = (0.5 * $rms_dani) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_dani = $violations_dani + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  dani print threshold = 0.20 class dan3 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_dani = (0.5 * $rms_dani) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_dani = $violations_dani + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  dani print threshold = 0.20 class dan4 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_dani = (0.5 * $rms_dani) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_dani = $violations_dani + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  dani print threshold = 0.20 class dan5 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_dani = (0.5 * $rms_dani) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_dani = $violations_dani + $violations) 
 CNSsolve>else 
 CNSsolve>  evaluate( $rms_dani = 0) 
 CNSsolve>  evaluate( $violations_dani = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>{====>} {* define ASA-based solvation parameters *} 
 CNSsolve>inline  
 CNSsolve>! 
 CNSsolve>! Define atomic solvation parameters taken from Fernandez-Recia et al. JMB 335:843 (2004) 
 CNSsolve>! 
 CNSsolve>evaluate ($arofac = 6.26) 
 CNSsolve>evaluate ($alifac = 1.27) 
 CNSsolve>evaluate ($polfac = 2.30) 
 CNSsolve>do (store1 =  0.0000) (all) 
 CNSsolve>do (store1 =  0.0151 * $alifac) (name C*) 
 CNSsolve>do (store1 =  0.0176 * $arofac) ((name CG* or name CD* or name CE* or name CH* or name CZ*) and (resn PHE or resn TYR or resn HIS or resn TRP)) 
 CNSsolve>do (store1 = -0.0170 * $polfac) (name N*) 
 CNSsolve>do (store1 = -0.0548 * $polfac) (name NT* or (name NZ* and resn LYS)) 
 CNSsolve>do (store1 = -0.0273 * $polfac) (name NH* and resn ARG) 
 CNSsolve>do (store1 = -0.0136 * $polfac) (name O*) 
 CNSsolve>do (store1 = -0.0185 * $polfac) (name OG* or name OH) 
 CNSsolve>do (store1 = -0.0299 * $polfac) ((name OD* and resn ASP) or (name OE* and resn GLU)) 
 CNSsolve>do (store1 =  0.0112 * $polfac) (name S*) 
 CNSsolve>do (store1 =  0.0022 * $polfac) ((name S* and attr charge = -0.3) or (name SD and resn MET)) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>{====>} {* buried surface area *} 
 CNSsolve>evaluate ($nchain1 = 1) 
 CNSsolve>evaluate ($saafree = 0) 
 CNSsolve>while ($nchain1 <= $data.ncomponents) loop nloop1 
 CNSsolve>  {====>} {* buried surface area *} 
 CNSsolve>  do (rmsd = 0) (all) 
 CNSsolve>  surface mode=access accu=0.075 rh2o=1.4 sele=(segid $Toppar.prot_segid_$nchain1 and not (resn TIP3 or resn DMS)) end 
 CNSsolve>  show sum (rmsd) (segid $Toppar.prot_segid_$nchain1 and not (resn TIP3 or resn DMS)) 
 CNSsolve>  evaluate ($saafree = $saafree + $result) 
 CNSsolve>  evaluate ($nchain1 = $nchain1 + 1) 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>do (rmsd = 0) (all) 
 CNSsolve>do (store2 = 0) (all) 
 CNSsolve>surface mode=access accu=0.075 rh2o=1.4 sele=(not (resn TIP3 or resn DMS)) end 
 CNSsolve>show sum (rmsd) (not (resn TIP3 or resn DMS)) 
 CNSsolve>evaluate ($satot = $result) 
 CNSsolve>do (store2 = rmsd * store1) (not (resn TIP3 or resn DMS)) 
 CNSsolve>show sum (store2) (not (resn TIP3 or resn DMS)) 
 CNSsolve>evaluate ($esolcplx = $result) 
 CNSsolve>evaluate ($saburied = $saafree - $satot) 
 CNSsolve>evaluate ($edesolv = $esolcplx - $esolfree) 
 CNSsolve>evaluate ($dhbinding = $edesolv + $eintcplx - $eintfree + $elec + $vdw) 
 CNSsolve>display COMPLEX dH OF BINDING = $dhbinding 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sym eq true) then 
 CNSsolve>  evaluate ($enerall = $enerall + $esym) 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.ncs eq true) then 
 CNSsolve>  evaluate ($enerall = $enerall + $ncs) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($data.waterdock eq true) then 
 CNSsolve>  ident (store3) (not all) 
 CNSsolve>  flag exclude * include vdw elec  end 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    igroup 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1) (resn TIP3 and not store3) weight * 1.0 end 
 CNSsolve>      interaction (not segid $Toppar.prot_segid_$nchain1) (resn TIP3) weight * 0.0 end 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1) (not (resn TIP3 and store3)) weight * 0.0 end 
 CNSsolve>    end 
 CNSsolve>    energy end 
 CNSsolve>    evaluate ($ener_water_$nchain1 = $ener) 
 CNSsolve>    evaluate ($enerall = $enerall + $ener) 
 CNSsolve>    evaluate ($vdw_water_$nchain1 = $vdw) 
 CNSsolve>    evaluate ($elec_water_$nchain1 = $elec) 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve>  if ($data.ncomponents < 6) then 
 CNSsolve>    eval($nchain1 = $data.ncomponents) 
 CNSsolve>    while ($nchain1 < 6) loop nloop1 
 CNSsolve>      eval($nchain1 = $nchain1 + 1) 
 CNSsolve>      evaluate ($ener_water_$nchain1 = 0.0) 
 CNSsolve>      evaluate ($vdw_water_$nchain1 = 0.0) 
 CNSsolve>      evaluate ($elec_water_$nchain1 = 0.0) 
 CNSsolve>    end loop nloop1 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  igroup 
 CNSsolve>    while ($nchain1 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain1 = $nchain1 + 1) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1) (all) weight * 0.0 end 
 CNSsolve>    end loop nloop2 
 CNSsolve>    interaction (resn TIP3 and not store3) (resn TIP3 and not store3)  weight * 1.0 end 
 CNSsolve>    interaction (store3) (store3)  weight * 0.0 end 
 CNSsolve>  end 
 CNSsolve>  energy end 
 CNSsolve>  evaluate ($ener_water_water = $ener) 
 CNSsolve>  evaluate ($enerall = $enerall + $ener) 
 CNSsolve>  evaluate ($vdw_water_water = $vdw) 
 CNSsolve>  evaluate ($elec_water_water = $elec) 
 CNSsolve>else 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < 6) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    evaluate ($ener_water_$nchain1 = 0.0) 
 CNSsolve>    evaluate ($vdw_water_$nchain1 = 0.0) 
 CNSsolve>    evaluate ($elec_water_$nchain1 = 0.0) 
 CNSsolve>  end loop nloop1 
 CNSsolve>  evaluate ($ener_water_water = 0.0) 
 CNSsolve>  evaluate ($vdw_water_water = 0.0) 
 CNSsolve>  evaluate ($elec_water_water = 0.0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks HADDOCK run for $filename 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks            total,bonds,angles,improper,dihe,vdw,elec,noe,cdih,coup,sani,vean,dani 
 CNSsolve>remarks energies: $enerall, $bondall, $anglall, $imprall, $diheall, $vdwall, $elecall, $noeall, $cdihall, $coupall, $saniall, $veanall, $daniall 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks            bonds,angles,impropers,dihe,noe,cdih,coup,sani,vean,dani 
 CNSsolve>remarks rms-dev.: $rms_bonds,$rms_angles,$rms_impropers,$rms_dihedrals,$rms_noe,$rms_cdih,$rms_coup, $rms_sani, $rms_vean, $rms_dani 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks               noe,cdih,coup,sani,vean,dani 
 CNSsolve>remarks               >0.3,>5,>1,>0,>5,>0.2 
 CNSsolve>remarks violations.: $violations_noe, $violations_cdih, $violations_coup, $violations_sani, $violations_vean, $violations_dani 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks                        CVpartition#,violations,rms 
 CNSsolve>remarks AIRs cross-validation: $npart, $violations_test_noe, $rms_test_noe 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks NCS energy: $ncs 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks Symmetry energy: $esym 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks Desolvation energy: $edesolv 
 CNSsolve>remarks Internal energy free molecules: $eintfree 
 CNSsolve>remarks Internal energy complex: $eintcplx 
 CNSsolve>remarks Binding energy: $dhbinding 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks buried surface area: $saburied 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks water - chain1: $ener_water_1 $vdw_water_1 $elec_water_1 
 CNSsolve>remarks water - chain2: $ener_water_2 $vdw_water_2 $elec_water_2 
 CNSsolve>remarks water - chain3: $ener_water_3 $vdw_water_3 $elec_water_3 
 CNSsolve>remarks water - chain4: $ener_water_4 $vdw_water_4 $elec_water_4 
 CNSsolve>remarks water - chain5: $ener_water_5 $vdw_water_5 $elec_water_5 
 CNSsolve>remarks water - chain6: $ener_water_6 $vdw_water_6 $elec_water_6 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks water - water: $ener_water_water $vdw_water_water $elec_water_water 
 CNSsolve>remarks =============================================================== 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  coor sele= (segid $Toppar.prot_segid_1) orient end 
 CNSsolve>  write coordinates sele= (all) output =$filename end 
 CNSsolve>  write structure output =$psfname end 
 CNSsolve> 
 CNSsolve>  end if 
 CNSsolve>end loop readpdb 
 CNSsolve>stop 
          ============================================================
           Maximum dynamic memory allocation:     8258152 bytes
           Maximum dynamic memory overhead:           288 bytes
           Program started at: 07:43:04 on 14-Oct-2020
           Program stopped at: 07:43:04 on 14-Oct-2020
           CPU time used:       0.0536 seconds
          ============================================================
